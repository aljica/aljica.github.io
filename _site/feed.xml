<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.6">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2023-05-29T17:30:36+02:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">aljica</title><subtitle></subtitle><entry><title type="html">Chapter 4 Process Control</title><link href="http://localhost:4000/sysadmin/2023/05/29/sysadmin-ch4.html" rel="alternate" type="text/html" title="Chapter 4 Process Control" /><published>2023-05-29T00:00:00+02:00</published><updated>2023-05-29T00:00:00+02:00</updated><id>http://localhost:4000/sysadmin/2023/05/29/sysadmin-ch4</id><content type="html" xml:base="http://localhost:4000/sysadmin/2023/05/29/sysadmin-ch4.html"><![CDATA[<h3 id="41-components-of-a-process">4.1 Components of a Process</h3>

<ul>
  <li>A process has a virtual address space, which maps into pages in physical memory.
    <ul>
      <li>A page is a sub-section of physical memory
        <ul>
          <li>Physical memory is equally divided into pages</li>
        </ul>
      </li>
      <li>These pages are randomly distributed in physical memory.</li>
      <li>A process consists of code, libraries, variables, stack, heap, etc.</li>
    </ul>
  </li>
  <li>Kernel internal data structures maintains:
    <ul>
      <li>A table that maps virtual address space to physical memory pages</li>
      <li>CPU, memory usage information</li>
      <li>Status</li>
      <li>Etc</li>
    </ul>
  </li>
  <li>All processes have one main thread</li>
  <li>They can have multiple threads, which can run simultaneously on multicore computer systems</li>
  <li>Threads of one process share the same memory</li>
</ul>

<h1 id="pid-process-id-number">PID: Process ID Number</h1>

<ul>
  <li>Each process gets an ID.</li>
  <li>Namespaces can further segregate/isolate processes from each other.
    <ul>
      <li>With namespaces, a process can have different PIDs depending on which other process is checking for it.</li>
    </ul>
  </li>
</ul>

<h1 id="ppid-parent-pid">PPID: Parent PID</h1>

<ul>
  <li>Parent &amp; Child processes.</li>
  <li>If the parent dies, init/systemd becomes the new parent.</li>
  <li>Misbehaving applications can be traced back to their parents; this can be helpful.</li>
</ul>

<h1 id="uid-and-euid-realeffective-user-id">UID and EUID: real/effective user ID</h1>

<ul>
  <li>Process has UID value; this is the UID of the user who created the parent process.</li>
  <li>Effective UID: the files/programs a process has access to.</li>
  <li>UID/EUID different only for SETUID programs.</li>
  <li>Saved UID: A SETUID program can place its root privileges here for most of execution, and only change the EUID for the SID for when it needs root.</li>
</ul>

<h1 id="gid-and-egid-real-and-effective-group-id">GID and EGID: real and effective group ID</h1>

<ul>
  <li>Same concept as for UID and EUID, but for groups.</li>
  <li>GID is really only relevant when a process creates new files; depending on file system permission settings, new files might set the GID of its creator as owner.</li>
</ul>

<h1 id="niceness">Niceness</h1>

<ul>
  <li>A process gets scheduled based on 2 main factors, derived from an algorithm:
    <ol>
      <li>How much CPU time it has used, and</li>
      <li>how long it has waited to execute.</li>
    </ol>
  </li>
</ul>

<h1 id="control-terminal">Control terminal</h1>

<ul>
  <li>For nondaemon processes, a control terminal determines that process’s STDIN/STDOUT/STDERR channels, sends the process keyboard events (CTRL+C) etc.</li>
  <li>When you use your terminal to run a command/process, your terminal acts as a control terminal.</li>
</ul>

<h3 id="42-the-lifecycle-of-a-process">4.2 The Lifecycle of a Process</h3>

<ul>
  <li>fork() system call copies a parent process’s memory, code, variables, stack, heap, etc, into a child process.
    <ul>
      <li>clone() is actually used behind the scenes of fork() - clone() includes threads and additional features.</li>
    </ul>
  </li>
  <li>fork() returns 2 different values - the child process gets the value 0, the parent gets the PID of the newly created child.
    <ul>
      <li>This way, in the code, you can have an if statement that checks if(fork() == 0) - then you know you are executing inside the child process.</li>
      <li>If fork() equals PID of the child, then you are executing in the parent process.</li>
    </ul>
  </li>
  <li>The child can use an exec() command to run another command.
    <ul>
      <li>Exec() also resets various memory segments so that the newly executing command becomes its own process entirely; the fork() command helps it setup the core things needed for a process - e.g. code, variables, stack, heap, etc. by simply copying them from the parent - but then it can change those and run as an entirely independent process.</li>
    </ul>
  </li>
</ul>]]></content><author><name></name></author><category term="sysadmin" /><summary type="html"><![CDATA[4.1 Components of a Process A process has a virtual address space, which maps into pages in physical memory. A page is a sub-section of physical memory Physical memory is equally divided into pages These pages are randomly distributed in physical memory. A process consists of code, libraries, variables, stack, heap, etc. Kernel internal data structures maintains: A table that maps virtual address space to physical memory pages CPU, memory usage information Status Etc All processes have one main thread They can have multiple threads, which can run simultaneously on multicore computer systems Threads of one process share the same memory PID: Process ID Number Each process gets an ID. Namespaces can further segregate/isolate processes from each other. With namespaces, a process can have different PIDs depending on which other process is checking for it. PPID: Parent PID Parent &amp; Child processes. If the parent dies, init/systemd becomes the new parent. Misbehaving applications can be traced back to their parents; this can be helpful. UID and EUID: real/effective user ID Process has UID value; this is the UID of the user who created the parent process. Effective UID: the files/programs a process has access to. UID/EUID different only for SETUID programs. Saved UID: A SETUID program can place its root privileges here for most of execution, and only change the EUID for the SID for when it needs root. GID and EGID: real and effective group ID Same concept as for UID and EUID, but for groups. GID is really only relevant when a process creates new files; depending on file system permission settings, new files might set the GID of its creator as owner. Niceness A process gets scheduled based on 2 main factors, derived from an algorithm: How much CPU time it has used, and how long it has waited to execute. Control terminal For nondaemon processes, a control terminal determines that process’s STDIN/STDOUT/STDERR channels, sends the process keyboard events (CTRL+C) etc. When you use your terminal to run a command/process, your terminal acts as a control terminal. 4.2 The Lifecycle of a Process fork() system call copies a parent process’s memory, code, variables, stack, heap, etc, into a child process. clone() is actually used behind the scenes of fork() - clone() includes threads and additional features. fork() returns 2 different values - the child process gets the value 0, the parent gets the PID of the newly created child. This way, in the code, you can have an if statement that checks if(fork() == 0) - then you know you are executing inside the child process. If fork() equals PID of the child, then you are executing in the parent process. The child can use an exec() command to run another command. Exec() also resets various memory segments so that the newly executing command becomes its own process entirely; the fork() command helps it setup the core things needed for a process - e.g. code, variables, stack, heap, etc. by simply copying them from the parent - but then it can change those and run as an entirely independent process.]]></summary></entry><entry><title type="html">Chapter 6 Cryptography and Symmetric Key Algorithms</title><link href="http://localhost:4000/cissp/2023/05/23/cissp-ch6.html" rel="alternate" type="text/html" title="Chapter 6 Cryptography and Symmetric Key Algorithms" /><published>2023-05-23T00:00:00+02:00</published><updated>2023-05-23T00:00:00+02:00</updated><id>http://localhost:4000/cissp/2023/05/23/cissp-ch6</id><content type="html" xml:base="http://localhost:4000/cissp/2023/05/23/cissp-ch6.html"><![CDATA[<ul>
  <li>Cryptographic provides CIA for:
    <ul>
      <li>Data at rest.</li>
      <li>Data in transit.</li>
      <li>Data in use (in memory).</li>
    </ul>
  </li>
  <li>Historical “arms race” of researchers developing stronger encryption algorithms, while hackers tried to break them.
    <ul>
      <li>We now have very sophisticated algorithms.</li>
    </ul>
  </li>
</ul>

<h3 id="cryptographic-foundations">Cryptographic Foundations</h3>

<h1 id="goals-of-cryptography">Goals of Cryptography</h1>

<ul>
  <li>4 fundamentals goals:
    <ul>
      <li>Confidentiality</li>
      <li>Integrity</li>
      <li>Authentication</li>
      <li>Nonrepudiation</li>
    </ul>
  </li>
  <li>Not all cryptosystems are designed to reach each goal.</li>
</ul>

<h4 id="confidentiality">Confidentiality</h4>

<ul>
  <li>Data remains private in rest, in transit, in use.</li>
  <li>“The preservation of secrecy”.</li>
  <li>Symmetric cryptosystems
    <ul>
      <li>Shared key among users</li>
    </ul>
  </li>
  <li>Asymmetric cryptosystems
    <ul>
      <li>Unique public/private keypair for each user</li>
    </ul>
  </li>
  <li>Data at rest
    <ul>
      <li>On hard drives, backup tapes, USB, etc.</li>
      <li>Data leak through physical theft of device</li>
    </ul>
  </li>
  <li>Data in motion (“data on the wire”)
    <ul>
      <li>Transmissions over network mediums</li>
      <li>Data leak through eavesdropping attacks</li>
    </ul>
  </li>
  <li>Data in use
    <ul>
      <li>Active in computer memory</li>
      <li>Data leak through improper process isolation at operating system-layer</li>
    </ul>
  </li>
</ul>

<h4 id="integrity">Integrity</h4>

<ul>
  <li>Ensures that data is not altered without authorization.</li>
  <li>Encrypted message digests.
    <ul>
      <li>Digital signatures (created using cryptography) to verify the contents of a message.</li>
      <li>A recipient can then re-compute the signature for a message and compare it with the previous one to see if the message has been tampered with.</li>
    </ul>
  </li>
  <li>Ensures data was not altered between time of creation and time of access.</li>
  <li>Allows for file integrity checking.</li>
</ul>

<h4 id="authentication">Authentication</h4>

<ul>
  <li>Verify a claimed identity.</li>
  <li>Challenge-Response authentication protocol:
    <ul>
      <li>Alice and Bob have a shared secret key and wish to communicate.</li>
      <li>When they begin communicating online and claim who they are, Alice can ask Bob to encrypt a short message with the secret key they both know.</li>
      <li>If Bob can return such an encrypted message, Alice can be certain it’s him, because only they know that secret key.</li>
    </ul>
  </li>
</ul>

<p><img src="/docs/assets/images/cissp/ch6/alice-bob-auth.png" alt="Image" /></p>

<h4 id="nonrepudiation">Nonrepudiation</h4>

<ul>
  <li>Ensures who sent a message, and the fact that they did send that message.</li>
  <li>If only Bob knows the secret key, it must have been him who sent the message.
    <ul>
      <li>He can’t later claim he didn’t.</li>
      <li>Unless the key was somehow leaked of course!</li>
    </ul>
  </li>
  <li>This property is provided by ASYMMETRIC cryptosystems.</li>
</ul>

<h1 id="cryptography-concepts">Cryptography Concepts</h1>

<ul>
  <li>Plaintext (denoted “P”)
    <ul>
      <li>Regular message before encryption</li>
    </ul>
  </li>
  <li>Sender uses an algorithm used to <em>encrypt</em> <em>plaintext</em>
    <ul>
      <li>This produces a <em>ciphertext</em> (C)</li>
    </ul>
  </li>
  <li>
    <p>Recipient uses an algorithm (not necessarily different from the one sender used) to <em>decrypt</em> the C into P.</p>
  </li>
  <li>Cryptographic algorithms rely on <em>keys</em>
    <ul>
      <li>Key = usually just a number</li>
    </ul>
  </li>
  <li>Each algorithm has its own <em>key space</em>
    <ul>
      <li>Key space = Valid range of values for a key</li>
      <li>Defined by its <em>bit size</em>
        <ul>
          <li>Number of binary digits (1s and 0s) in the key</li>
        </ul>
      </li>
      <li>If bit size is 5, then key space is the range of numbers:
        <ul>
          <li>00000 (in binary) = 0 (in decimal)</li>
          <li>11111 = 31 (i.e. 2<sup>5</sup>)</li>
        </ul>
      </li>
      <li>128-bit key has key space from 0 to 2<sup>128</sup></li>
      <li>n-bit key has key space from 0 to 2<sup>n</sup></li>
    </ul>
  </li>
  <li>
    <p>Keep your keys SECRET!</p>
  </li>
  <li>Kerchkoff’s Principle
    <ul>
      <li>Algorithms used for encryption &amp; decryption should be public</li>
      <li>Cryptographic system should be secure even if everything except the secret key is known!
        <ul>
          <li>Security through obscurity is not better.
            <ul>
              <li>Public exposure =&gt; researchers can find weaknessess/faults quicker!</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li><em>“Cryptovariables”</em> - name for cryptographic keys</li>
  <li><em>“Cryptography”</em> - Creating/implementing secret codes/ciphers</li>
  <li><em>“Cryptanalysis”</em> - the study of methods to defeat ciphers</li>
  <li><em>“Cryptology”</em> - Cryptography &amp; Cryptanalysis combined</li>
  <li><em>“Cryptosystems”</em> - Specific implementations of a cipher in hardware/software</li>
  <li>Federal Information Processing Standard (FIPS) 140-2 “Security Requirements for Cryptographic Modules”
    <ul>
      <li>Document outlining the hardware/software requirements for federal government in the U.S.</li>
    </ul>
  </li>
</ul>

<h1 id="cryptographic-mathematics">Cryptographic Mathematics</h1>

<ul>
  <li>We will here discuss mathematics; logical operations that are the foundations of cryptography.</li>
  <li>You will not need to do math or solve cryptographical problems in a mathematical sense; but it’s vital for your understanding!</li>
</ul>

<h4 id="boolean-mathematics">Boolean Mathematics</h4>

<ul>
  <li>Decimal system - base 10 system
    <ul>
      <li>Each place value in a number is a multiple of 10</li>
      <li>E.g. the number “21” can be calculated (going from right to left):
        <ul>
          <li>1 * 10<sup>0</sup> + 2 * 10<sup>1</sup> = 1 * 1 + 2 * 10 = 1 + 20 = 21</li>
        </ul>
      </li>
      <li>In binary, “1011 is calculated as (going from right to left):
        <ul>
          <li>1 * 2<sup>0</sup> + 1 * 2<sup>1</sup> + 0 * 2<sup>2</sup> + 1 * 2<sup>3</sup> = 1 + 2 + 0 + 8 = 11</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h4 id="logical-operations">Logical operations</h4>

<ul>
  <li>Manipulating data:</li>
</ul>

<h4 id="and-operation">AND operation</h4>

<ul>
  <li>Symbol ^
    <ul>
      <li>E.g. 1011 ^ 1111</li>
      <li>The AND operation takes TWO inputs at a time.</li>
      <li>So from 1011, we take the 1 from the left, and from 1111, we take the 1 from the left, and we input them to the AND function
        <ul>
          <li>The AND operation returns 1 if both input bits are 1, and returns 0 otherwise:</li>
          <li>Since both are 1’s, the first output/return value in the resulting number is also 1</li>
        </ul>
      </li>
      <li>See the examples below.</li>
    </ul>
  </li>
</ul>

<p><img src="/docs/assets/images/cissp/ch6/x-y-boolean.jpeg" alt="Image" /></p>

<p><img src="/docs/assets/images/cissp/ch6/full-and.jpeg" alt="Image" /></p>

<h4 id="or">OR</h4>

<ul>
  <li>The symbol for OR is V.</li>
  <li>If X and Y are both 0, the output is 0.
    <ul>
      <li>Else, the output is 1.</li>
    </ul>
  </li>
  <li>Can you figure out the output of X: 0 1 1 0 1 1 0 0 OR Y: 1 0 1 0 0 1 1 1?</li>
</ul>
<details>
    <summary>Answer</summary>

    X V Y: 1 1 1 0 1 1 1 1

</details>

<h4 id="not">NOT</h4>

<ul>
  <li>Symbol for NOT is ~</li>
  <li>Invert a bit</li>
  <li>If X is 1, ~X would be 0, and vice versa.</li>
</ul>

<h4 id="exclusive-or-xor">Exclusive OR (XOR)</h4>

<ul>
  <li>Symbol is ⊕</li>
  <li>If X and Y are both 0’s or 1’s, the output is 0.
    <ul>
      <li>Else, if X and Y are both different (e.g. X is 0 and Y is 1, or X is 1 and Y is 0), the output is 1.</li>
    </ul>
  </li>
  <li>Can you solve 0 1 1 0 1 1 0 0 ⊕ 1 0 1 0 0 1 1 1</li>
</ul>

<details>
    <summary>Answer</summary>

    X &oplus; Y: 1 1 0 0 1 0 1 1

</details>

<h4 id="modulo-function">Modulo function</h4>

<ul>
  <li>Symbol can be either the word “mod” or the percentage %</li>
  <li>Modulo returns the remainder of a division operation
    <ul>
      <li>Let’s say you divide 6 by 4, i.e. 6 / 4</li>
      <li>The result is 1 (because 4 fits only once into 6) with a remainder value of 2</li>
      <li>The module function outputs that remainder value 2
        <ul>
          <li>So: 6 mod 4 = 6 % 4 = 2</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Can you figure out what 33 mod 10 is?</li>
</ul>
<details>
    <summary>Answer</summary>

    33 mod 10 = 33 % 10 = 3

</details>

<h4 id="one-way-functions">One-Way Functions</h4>]]></content><author><name></name></author><category term="cissp" /><summary type="html"><![CDATA[Cryptographic provides CIA for: Data at rest. Data in transit. Data in use (in memory). Historical “arms race” of researchers developing stronger encryption algorithms, while hackers tried to break them. We now have very sophisticated algorithms. Cryptographic Foundations Goals of Cryptography 4 fundamentals goals: Confidentiality Integrity Authentication Nonrepudiation Not all cryptosystems are designed to reach each goal. Confidentiality Data remains private in rest, in transit, in use. “The preservation of secrecy”. Symmetric cryptosystems Shared key among users Asymmetric cryptosystems Unique public/private keypair for each user Data at rest On hard drives, backup tapes, USB, etc. Data leak through physical theft of device Data in motion (“data on the wire”) Transmissions over network mediums Data leak through eavesdropping attacks Data in use Active in computer memory Data leak through improper process isolation at operating system-layer Integrity Ensures that data is not altered without authorization. Encrypted message digests. Digital signatures (created using cryptography) to verify the contents of a message. A recipient can then re-compute the signature for a message and compare it with the previous one to see if the message has been tampered with. Ensures data was not altered between time of creation and time of access. Allows for file integrity checking. Authentication Verify a claimed identity. Challenge-Response authentication protocol: Alice and Bob have a shared secret key and wish to communicate. When they begin communicating online and claim who they are, Alice can ask Bob to encrypt a short message with the secret key they both know. If Bob can return such an encrypted message, Alice can be certain it’s him, because only they know that secret key. Nonrepudiation Ensures who sent a message, and the fact that they did send that message. If only Bob knows the secret key, it must have been him who sent the message. He can’t later claim he didn’t. Unless the key was somehow leaked of course! This property is provided by ASYMMETRIC cryptosystems. Cryptography Concepts Plaintext (denoted “P”) Regular message before encryption Sender uses an algorithm used to encrypt plaintext This produces a ciphertext (C) Recipient uses an algorithm (not necessarily different from the one sender used) to decrypt the C into P. Cryptographic algorithms rely on keys Key = usually just a number Each algorithm has its own key space Key space = Valid range of values for a key Defined by its bit size Number of binary digits (1s and 0s) in the key If bit size is 5, then key space is the range of numbers: 00000 (in binary) = 0 (in decimal) 11111 = 31 (i.e. 25) 128-bit key has key space from 0 to 2128 n-bit key has key space from 0 to 2n Keep your keys SECRET! Kerchkoff’s Principle Algorithms used for encryption &amp; decryption should be public Cryptographic system should be secure even if everything except the secret key is known! Security through obscurity is not better. Public exposure =&gt; researchers can find weaknessess/faults quicker! “Cryptovariables” - name for cryptographic keys “Cryptography” - Creating/implementing secret codes/ciphers “Cryptanalysis” - the study of methods to defeat ciphers “Cryptology” - Cryptography &amp; Cryptanalysis combined “Cryptosystems” - Specific implementations of a cipher in hardware/software Federal Information Processing Standard (FIPS) 140-2 “Security Requirements for Cryptographic Modules” Document outlining the hardware/software requirements for federal government in the U.S. Cryptographic Mathematics We will here discuss mathematics; logical operations that are the foundations of cryptography. You will not need to do math or solve cryptographical problems in a mathematical sense; but it’s vital for your understanding! Boolean Mathematics Decimal system - base 10 system Each place value in a number is a multiple of 10 E.g. the number “21” can be calculated (going from right to left): 1 * 100 + 2 * 101 = 1 * 1 + 2 * 10 = 1 + 20 = 21 In binary, “1011 is calculated as (going from right to left): 1 * 20 + 1 * 21 + 0 * 22 + 1 * 23 = 1 + 2 + 0 + 8 = 11 Logical operations Manipulating data: AND operation Symbol ^ E.g. 1011 ^ 1111 The AND operation takes TWO inputs at a time. So from 1011, we take the 1 from the left, and from 1111, we take the 1 from the left, and we input them to the AND function The AND operation returns 1 if both input bits are 1, and returns 0 otherwise: Since both are 1’s, the first output/return value in the resulting number is also 1 See the examples below. OR The symbol for OR is V. If X and Y are both 0, the output is 0. Else, the output is 1. Can you figure out the output of X: 0 1 1 0 1 1 0 0 OR Y: 1 0 1 0 0 1 1 1? Answer X V Y: 1 1 1 0 1 1 1 1 NOT Symbol for NOT is ~ Invert a bit If X is 1, ~X would be 0, and vice versa. Exclusive OR (XOR) Symbol is ⊕ If X and Y are both 0’s or 1’s, the output is 0. Else, if X and Y are both different (e.g. X is 0 and Y is 1, or X is 1 and Y is 0), the output is 1. Can you solve 0 1 1 0 1 1 0 0 ⊕ 1 0 1 0 0 1 1 1 Answer X &oplus; Y: 1 1 0 0 1 0 1 1 Modulo function Symbol can be either the word “mod” or the percentage % Modulo returns the remainder of a division operation Let’s say you divide 6 by 4, i.e. 6 / 4 The result is 1 (because 4 fits only once into 6) with a remainder value of 2 The module function outputs that remainder value 2 So: 6 mod 4 = 6 % 4 = 2 Can you figure out what 33 mod 10 is? Answer 33 mod 10 = 33 % 10 = 3 One-Way Functions]]></summary></entry><entry><title type="html">Fundamentals of Software Architecture Chapter 9 Foundations</title><link href="http://localhost:4000/architecture/2023/05/22/fundamentals-of-software-architecture-ch9.html" rel="alternate" type="text/html" title="Fundamentals of Software Architecture Chapter 9 Foundations" /><published>2023-05-22T00:00:00+02:00</published><updated>2023-05-22T00:00:00+02:00</updated><id>http://localhost:4000/architecture/2023/05/22/fundamentals-of-software-architecture-ch9</id><content type="html" xml:base="http://localhost:4000/architecture/2023/05/22/fundamentals-of-software-architecture-ch9.html"><![CDATA[<p><a href="#9-1-foundations">9.1 Foundations</a></p>

<h1 id="9-1-foundations">9 1 Foundations</h1>

<ul>
  <li>First Point</li>
</ul>]]></content><author><name></name></author><category term="architecture" /><summary type="html"><![CDATA[9.1 Foundations 9 1 Foundations First Point]]></summary></entry><entry><title type="html">Kubernetes Architecture</title><link href="http://localhost:4000/kubernetes/2023/05/22/kubernetes-architecture.html" rel="alternate" type="text/html" title="Kubernetes Architecture" /><published>2023-05-22T00:00:00+02:00</published><updated>2023-05-22T00:00:00+02:00</updated><id>http://localhost:4000/kubernetes/2023/05/22/kubernetes-architecture</id><content type="html" xml:base="http://localhost:4000/kubernetes/2023/05/22/kubernetes-architecture.html"><![CDATA[<ul>
  <li><a href="#1-architecture">1 Architecture</a>
    <ul>
      <li><a href="#1-1-kubernetes-objects">1.1 Kubernetes Objects</a></li>
      <li><a href="#1-2-kubernetes-components">1.2 Kubernetes Components</a></li>
      <li><a href="#1-3-k8s-api">1.3 K8s API</a></li>
    </ul>
  </li>
</ul>

<h2 id="1-architecture">1 Architecture</h2>

<h1 id="1-1-kubernetes-objects">1 1 Kubernetes Objects</h1>

<ul>
  <li>They can describe the state of your deployed applications</li>
  <li>Resources available to those applications</li>
  <li>Policies around how those apps behave</li>
</ul>

<h1 id="1-2-kubernetes-components">1 2 Kubernetes Components</h1>

<ul>
  <li>Kubernetes Cluster
    <ul>
      <li>Consists of multiple worker nodes / physical machines</li>
      <li>Each worker node consists of pods, which are containerized applications</li>
      <li>The K8s Control Plane usually runs on multiple computers, when in a real production environment.</li>
    </ul>
  </li>
  <li>Control Plane
    <ul>
      <li>Control plane components should ideally be deployed on machines dedicated to control plane functionality, and thus no application containers should be deployed here.</li>
      <li>Control plane components:
        <ul>
          <li>Kube-apiserver
            <ul>
              <li>Manages API access to the Kubernetes control plane.</li>
              <li>Can deploy multiple apiservers and load balance between them.</li>
            </ul>
          </li>
          <li>Etcd
            <ul>
              <li>Key-value store to store cluster data.</li>
            </ul>
          </li>
          <li>Kube-scheduler
            <ul>
              <li>When a pod gets created, the scheduler determines on which worker node it should run.
                <ul>
                  <li>This decision is based on factors such as policies, resource requirements, locality etc.</li>
                </ul>
              </li>
            </ul>
          </li>
          <li>Kube-controller-manager
            <ul>
              <li>Controls controller processes</li>
              <li>Controller processes are logically separate; but in practice, to reduce complexity, they run as one single binary</li>
              <li>Controller processes include:
                <ul>
                  <li>Node controller: handling worker nodes</li>
                  <li>Job controller: handlings jobs</li>
                  <li>ServiceAccount controller: Manages service accounts when new namespaces are created for example, etc.</li>
                </ul>
              </li>
            </ul>
          </li>
          <li>Cloud-controller-manager
            <ul>
              <li>It ensures only the necessary components in your cluster are talking to the cloud via cloud APIs, and that others are not.</li>
              <li>Further, it consists of:
                <ul>
                  <li>Node controller: Controlling nodes in the cloud, e.g. if one stops responding, checks if it’s been deleted.</li>
                  <li>Route controller: Manage/create routes in the underlying cloud infra.</li>
                  <li>Service controller: manage/create load balancers in the cloud.</li>
                </ul>
              </li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Node Components:
    <ul>
      <li>Kubelet
        <ul>
          <li>Agent running on each worker node.</li>
          <li>It creates Pods from PodSpecs</li>
          <li>It only manages K8s-created containers/Pods</li>
        </ul>
      </li>
      <li>Kube-proxy
        <ul>
          <li>Network filtering
            <ul>
              <li>Either uses underlying OS firewalling capabilities or kube-proxy does network filtering itself</li>
            </ul>
          </li>
          <li>Accept/deny network traffic from within/outside the cluster</li>
        </ul>
      </li>
      <li>Container runtime
        <ul>
          <li>E.g. Docker.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>AddOns
    <ul>
      <li>DNS
        <ul>
          <li>DNS Server for the K8s Cluster. Pods have their own FQDN.</li>
        </ul>
      </li>
      <li>Web UI
        <ul>
          <li>Troubleshoot/management console for K8s cluster and/or the applications running in pods.</li>
        </ul>
      </li>
      <li>Cluster-level logging
        <ul>
          <li>Save container logs to a central log store</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h1 id="1-3-k8s-api">1 3 K8s API</h1>
<ul>
  <li>Kubectl</li>
  <li>Kubeadm (uses kubectl in the background)</li>
  <li>Can also use REST API calls</li>
  <li>Protobuf for intra-cluster communications
    <ul>
      <li>Protocol for retrieving cluster data from etcd key-value store =&gt; serializing =&gt; … =&gt; deserializing at client =&gt; usage</li>
      <li>Apparently relatively fast</li>
    </ul>
  </li>
  <li>K8s stores serialized objects in etcd (key-value store)</li>
  <li>API Changes
    <ul>
      <li>Access a resource via v1beta1 until the API is deprecated; then you can access via new API e.g. v1. But generally you can access them via both as long as they’re both up.</li>
    </ul>
  </li>
</ul>]]></content><author><name></name></author><category term="kubernetes" /><summary type="html"><![CDATA[1 Architecture 1.1 Kubernetes Objects 1.2 Kubernetes Components 1.3 K8s API 1 Architecture 1 1 Kubernetes Objects They can describe the state of your deployed applications Resources available to those applications Policies around how those apps behave 1 2 Kubernetes Components Kubernetes Cluster Consists of multiple worker nodes / physical machines Each worker node consists of pods, which are containerized applications The K8s Control Plane usually runs on multiple computers, when in a real production environment. Control Plane Control plane components should ideally be deployed on machines dedicated to control plane functionality, and thus no application containers should be deployed here. Control plane components: Kube-apiserver Manages API access to the Kubernetes control plane. Can deploy multiple apiservers and load balance between them. Etcd Key-value store to store cluster data. Kube-scheduler When a pod gets created, the scheduler determines on which worker node it should run. This decision is based on factors such as policies, resource requirements, locality etc. Kube-controller-manager Controls controller processes Controller processes are logically separate; but in practice, to reduce complexity, they run as one single binary Controller processes include: Node controller: handling worker nodes Job controller: handlings jobs ServiceAccount controller: Manages service accounts when new namespaces are created for example, etc. Cloud-controller-manager It ensures only the necessary components in your cluster are talking to the cloud via cloud APIs, and that others are not. Further, it consists of: Node controller: Controlling nodes in the cloud, e.g. if one stops responding, checks if it’s been deleted. Route controller: Manage/create routes in the underlying cloud infra. Service controller: manage/create load balancers in the cloud. Node Components: Kubelet Agent running on each worker node. It creates Pods from PodSpecs It only manages K8s-created containers/Pods Kube-proxy Network filtering Either uses underlying OS firewalling capabilities or kube-proxy does network filtering itself Accept/deny network traffic from within/outside the cluster Container runtime E.g. Docker. AddOns DNS DNS Server for the K8s Cluster. Pods have their own FQDN. Web UI Troubleshoot/management console for K8s cluster and/or the applications running in pods. Cluster-level logging Save container logs to a central log store 1 3 K8s API Kubectl Kubeadm (uses kubectl in the background) Can also use REST API calls Protobuf for intra-cluster communications Protocol for retrieving cluster data from etcd key-value store =&gt; serializing =&gt; … =&gt; deserializing at client =&gt; usage Apparently relatively fast K8s stores serialized objects in etcd (key-value store) API Changes Access a resource via v1beta1 until the API is deprecated; then you can access via new API e.g. v1. But generally you can access them via both as long as they’re both up.]]></summary></entry><entry><title type="html">The Linux Programming Interface Chapter 12 Summary</title><link href="http://localhost:4000/tlpi/2023/05/22/tlpi-ch12.html" rel="alternate" type="text/html" title="The Linux Programming Interface Chapter 12 Summary" /><published>2023-05-22T00:00:00+02:00</published><updated>2023-05-22T00:00:00+02:00</updated><id>http://localhost:4000/tlpi/2023/05/22/tlpi-ch12</id><content type="html" xml:base="http://localhost:4000/tlpi/2023/05/22/tlpi-ch12.html"><![CDATA[<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>• /proc filesystem
	○ How many files are currently locked?
		§ Which processes are holding those locks?
	○ How many files is a process holding?
	○ Basically, getting information about processes.
	○ What sockets are being used?
• Traditionally, older UNIX implementations allowed privileged programs to access kernel data structures/memory directly to find information related to processes. This caused some problems.
	○ Now, the kernel provides a virtual file system under /proc.
		§ A virtual file system does not reside on disk; it is created on-the-fly when a program needs access to /proc to get/(set) process information.
	○ Programs can in a more convenient way access processes information via /proc and make changes to some aspects using system calls and regular file I/O.
• /proc/PID
	○ Contains process information
	○ /proc/PID/status
		§ This file contains the status of the process
		§ Because /proc/PID/status tends to change over time, don't parse the file by line number
			□ PARSE BY THE STRING, e.g. PPID: &lt;number&gt; which may change from being on line 7 to line 17 as new things are added to the file.
	○ Other files: cwd (current working dir), exe (symlink to file being executed), environ (env list), cmdline (cmdline arguments), mounts (mount points for the process), etc…
• /proc/PID/fd directory
	○ E.g. /proc/PID/fd/1 is a symlink to stdout (standard output) for that process
• A process can access its own /proc/PID dir through /proc/self
• Threads: /proc/PID/task/&lt;thread-id&gt;
	○ Because threads share memory, similar information is stored across threads under the corresponding thread-id directory.
	○ Information that might differ in for e.g. the status file are things like the current state of the thread, signals-related information and some other things.
• Various sub-directories for various settings
	○ /proc/net - networking/sockets settings
	○ /proc/sys/net - networking/sockets again
	○ Proc/kernel - kernel settings
	○ Etc
• Who/when can we modify /proc files?
	○ /proc/PID files can be modified by root or, for some of the files (e.g. environ), only the file owner (i.e. the user who created the process)
	○ Some files are read-only, meaning they cannot be modified, e.g. those that simply display kernel info
	○ Most files under /proc are owned by root, meaning only root can modify them.
• Uname(&amp;uts)
	○ Uts is a struct with a bunch of fields such as version, machine, system name, release etc…
	○ Basically uname returns a bunch of information about the host system.
</code></pre></div></div>

<p><img src="/docs/assets/images/tlpi-ch12/tlpi-ch12-1.jpg" alt="Image" /></p>]]></content><author><name></name></author><category term="tlpi" /><summary type="html"><![CDATA[• /proc filesystem ○ How many files are currently locked? § Which processes are holding those locks? ○ How many files is a process holding? ○ Basically, getting information about processes. ○ What sockets are being used? • Traditionally, older UNIX implementations allowed privileged programs to access kernel data structures/memory directly to find information related to processes. This caused some problems. ○ Now, the kernel provides a virtual file system under /proc. § A virtual file system does not reside on disk; it is created on-the-fly when a program needs access to /proc to get/(set) process information. ○ Programs can in a more convenient way access processes information via /proc and make changes to some aspects using system calls and regular file I/O. • /proc/PID ○ Contains process information ○ /proc/PID/status § This file contains the status of the process § Because /proc/PID/status tends to change over time, don't parse the file by line number □ PARSE BY THE STRING, e.g. PPID: &lt;number&gt; which may change from being on line 7 to line 17 as new things are added to the file. ○ Other files: cwd (current working dir), exe (symlink to file being executed), environ (env list), cmdline (cmdline arguments), mounts (mount points for the process), etc… • /proc/PID/fd directory ○ E.g. /proc/PID/fd/1 is a symlink to stdout (standard output) for that process • A process can access its own /proc/PID dir through /proc/self • Threads: /proc/PID/task/&lt;thread-id&gt; ○ Because threads share memory, similar information is stored across threads under the corresponding thread-id directory. ○ Information that might differ in for e.g. the status file are things like the current state of the thread, signals-related information and some other things. • Various sub-directories for various settings ○ /proc/net - networking/sockets settings ○ /proc/sys/net - networking/sockets again ○ Proc/kernel - kernel settings ○ Etc • Who/when can we modify /proc files? ○ /proc/PID files can be modified by root or, for some of the files (e.g. environ), only the file owner (i.e. the user who created the process) ○ Some files are read-only, meaning they cannot be modified, e.g. those that simply display kernel info ○ Most files under /proc are owned by root, meaning only root can modify them. • Uname(&amp;uts) ○ Uts is a struct with a bunch of fields such as version, machine, system name, release etc… ○ Basically uname returns a bunch of information about the host system.]]></summary></entry><entry><title type="html">The Linux Programming Interface Chapter 6 Processes Summary</title><link href="http://localhost:4000/tlpi/2023/05/22/tlpi-ch6.html" rel="alternate" type="text/html" title="The Linux Programming Interface Chapter 6 Processes Summary" /><published>2023-05-22T00:00:00+02:00</published><updated>2023-05-22T00:00:00+02:00</updated><id>http://localhost:4000/tlpi/2023/05/22/tlpi-ch6</id><content type="html" xml:base="http://localhost:4000/tlpi/2023/05/22/tlpi-ch6.html"><![CDATA[<p><a href="#6-1">6.1</a></p>

<p><a href="#6-2">6.2</a></p>

<p><a href="#6-3-memory-layout-of-a-process">6.3 Memory Layout of a Process</a></p>

<p><a href="#6-4-virtual-memory-management">6.4 Virtual Memory Management</a></p>

<p><a href="#6-6-command-line-arguments">6.6 Command Line Arguments</a></p>

<p><a href="#6-7-environment-list">6.7 Environment List</a></p>

<p><a href="#6-8-performing-a-non-local-goto">6.8 Performing a Non Local GoTo</a></p>

<h1 id="6-1">6 1</h1>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>• A program on disk consists of the following:
	1. Binary identification.
		i. What file-format it is. On Linux, ELF (Executable &amp; Linking format).
	2. Machine instructions.
	3. Location of entry-point (main function).
	4. Data/constants/strings.
	5. Names of variables/functions.
	6. Shared libraries.
	7. Other information on how to construct a process.
• Kernel data structures involved in maintaining a process:
	○ Virtual memory table/information.
	○ File descriptor table.
	○ Signal handling information.
	○ Resource usage/limits.
</code></pre></div></div>

<h1 id="6-2">6 2</h1>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>• Process ID (PID).
• Pid_t Getpid(void).
	○ Pid_t is an integer type.
• Maximum process ID number is 32,767. This is defined as a PID_MAX macro in Linux kernel.
• The PID number can be increased via /proc/sys/kernel/pid_max file.
• When the maximum PID number is reached, it begins from a low number again (PID 300, not PID 1, because PID 1 - 300 are often used by system daemons and processes).
• Pid_t getppid(void) - gets parent PID.
	○ See family tree of processes with pstree.
</code></pre></div></div>

<h1 id="6-3-memory-layout-of-a-process">6 3 Memory Layout of a Process</h1>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>• The layout:
	1. Machine instructions. Each process-instance of the program points to these machine instructions (and initialized/uninitialized data segments, described below).
	2. Initialized data segments. Explicitly declared variables.
		i. E.g. int I = 10;
	3. Uninitialized data segments, e.g. int I;. Not explicitly declared variables.
	4. Stack.
		i. Each new function call gets a stack frame in the stack.
		ii. Contains the function's local variables, parameters and return value.
	5. Heap.
		i. For dynamically allocating memory.
• (Un)initialized data in main() function get stored in the (un)initialized data segments (and not main()'s stack frame), whereas such data in another function get stored in the stack frame of that function.
• Application Binary Interface (ABI) - set of rules for communication. A binary executable informs kernel/some library on how they should exchange certain important information. The ABI tells the kernel which registers and stack locations it will use to exchange this information.
• Extern char etext, edata, end.
	○ Extern char etext is the next byte after the end of the program text/code/instructions.
	○ Edata is the unintiialized data segment.
	○ End is the init data segment.
</code></pre></div></div>

<h1 id="6-4-virtual-memory-management">6 4 Virtual Memory Management</h1>

<p><img src="/docs/assets/images/tlpi-6.4-1.jpg" alt="Image" /></p>

<p><img src="/docs/assets/images/tlpi-6.4-2.png" alt="Image" /></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>• Locality of reference
	○ Temporal locality
		§ A program will use the same information again if it used it recently
	○ Spatial locality
		§ A program will use information close to information it recently used
• RAM is divided into page frames
• Virtual memory is divided into pages as well
• Page size on Linux x86-32 = 4096 bytes
• Swap
	○ Can be used to store additional, unused pages.
		§ If a process requests a page that happens to be in swap, page fault occurs: kernel must pause the process's execution and fetch the page(s).
• Each process has a virtual page table.
	○ Each element in the virtual page table points to a page in virtual address memory.
		§ Each of these elements in turn point to either physical RAM memory where the page is stored, or indicate that the page is on disk.
	○ If a process tries to access an element in the virtual page table that does not exist, a SIGSEGV signal is sent.
		§ Unusued memory do not have to be added as entries in the virtual page table.
• 4 situations when virtual address space of a process can change as kernel allocates/deallocates memory:
	○ Stack grows downward
	○ Heap grows
	○ System-V related things
	○ Mmap() or munmap() is used
• There are 3 main benefits to mapping virtual addresses' of processes to physical RAM memory:
	○ Isolation
		§ A process only has access to the physical RAM pages that are mapped to that process's page table.
	○ Memory sharing
		§ Processes can share code, data, without duplicating it.
	○ Memory protection
		§ You can have different access privileges set for different processes for the same data.
			□ e.g. read for pid7, read-write for pid10.
• Stack starts at high address, and grows downward.
	○ Whenever a function call or global/main variable declaration is made, a stack frame is added.
	○ There's a register that keeps track of the current "top" of the stack, i.e. the end of the stack in the direction it grows in.
• Kernel memory/stack at beginning of each process
	○ If that user process makes a syscall, kernel can use this separate stack to add function calls.
• Functions use a program counter CPU register to keep track of which machine instructions to execute next.
	○ If another function is called, the new stack frame of the called function includes this machine instruction so that it can be saved, so that once the called function returns, the original function knows what to do.
</code></pre></div></div>

<p><img src="/docs/assets/images/tlpi-6.4-3.jpg" alt="Image" /></p>

<p><img src="/docs/assets/images/tlpi-6.4-4.png" alt="Image" /></p>

<h1 id="6-6-command-line-arguments">6 6 Command Line Arguments</h1>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>• Argc/argv
• Argv[0] is the name of the program
	○ The program can check the name used when calling it by looking at argv[0]
	○ The program can then have different behavior if for example the user called gzip as opposed to gunzip.
• The array of elements is terminated by a NULL-byte char, i.e. argv[argc] is NULL.
	○ Each string in argv[] is also null-terminated.
• Non-portable method of accessing commandline arguments on Linux:
	○ /proc/PID/cmdline
	○ Or /proc/self/cmdline if the process is getting its own cmdline args.
• ARG_MAX value, i.e. total number of bytes that can be supplied via args.
	○ Total space for argv and environ (env variables sorta) can be specified with RLIMIT_STACK resource limit.
</code></pre></div></div>

<h1 id="6-7-environment-list">6 7 Environment List</h1>

<p><img src="/docs/assets/images/tlpi-6.4-environ.png" alt="Image" /></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>• Children inherit parent data
• Environment variables: name=value pairs.
• Export SHELL=/bin/sh
	○ This is an example of an env var
	○ Printenv to see a list of all env vars
	○ Env list of any process can be found at /proc/PID/environ
• Accessing the environment from a C program
	○ **environ points to an array, where each element points to the environment variables
	○ Stepping through this array is done with pointers, even though it's an array.
		§ Reason being that there is no argc value that specifies the size of the environ array.
	○ Getenv(name) returns point to the value of an environment variable name
		§ THIS IS PORTABLE!!
	○ You can also make changes to environment variables with putenv() and setenv().
		§ Use case: when you use fork() to create child processes, you want the child processes to also have this modified environment.
	○ Executing SUID (set-used-ID) programs securely may require using clearenv() to clear all env vars first.
	○ When you call setenv(), a memory buffer is allocated to store the name=value pair.
		§ If a program repeatedly calls setenv() and clearenv(), this memory buffer does NOT get free'd.
			□ This could lead to memory leaks.
			□ In practice, it does not, because programs tend to use clearenv() only on startup.
</code></pre></div></div>

<h1 id="6-8-performing-a-non-local-goto">6 8 Performing a Non Local GoTo</h1>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>• Nonlocal goto means going from e.g. a function to some other memory area outside of the function.
• Caveat: you cannot goto another function from a current function using goto, but you CAN using setjmp() and longjmp().
• Example use case:
	○ Imagine multiple functions being called in a stack.
	○ Each called function supplies its caller with a status value.
	○ If an error status occurs at any stage, to go back to a normally executing function, we might have to pop several function calls from the stack.
		§ Instead of going one by one, we can use the setjmp() and longjmp() commands to directly jump back to an OK function.
• C does not allow for nested functions e.g. where you define X() then within X() you define Y(). So compiler has no way of knowing if Y is on the stack if a goto is written in X(). Pascal for example allows for this nesting and can thus in certain scenarios determine that a goto is possible.
• Jump calls:
	○ Setjmp(jmp_buf env);
		§ Returns 0 on initial return, val when a longjmp() returns to setjmp()
	○ Longjmp(jmp_buf env, int val);
		§ Val specifies  a value to supply the setjmp() with. That way, you can use val to distinguish which part of the program called setjmp(). If val is set to 0, it is automatically changed to 1 to avoid being misinterpreted as being the default 0.
	○ Env stores the following:
		1. Stack pointer register (that points to the top of the stack) (so it can "erase" unneeded function calls by simply moving the pointer to the same place it was when setjmp() was declared when longjmp() is called, accomplishing our intended purpose)
		2. Program counter register (so it knows where setjmp() was executing from)
		• Env usually declared as a global var (or, less commonly, passed as function param)
	○ There are restrictions specified by SUSv3 and C99 on when setjmp() can be used. Examples include:
		• If/while/switch
		• Etc
		• S = setjmp(env); is not standards conformant
			□ Somehow cannot guarantee setjmp() in this way has all the necessary info to save register values and the full stack.
• Abusing longjmp()
	1. Declare global buffer env.
	2. Inside x(), setjmp().
	3. x() returns.
	4. y() calls longjmp() to the setjmp() inside x().
		• PROBLEM: x() is NOT on the stack! Chaos ensues. Program crash or infinite call-return loop, where the program thinks it's returning from a legitimate call.
• Setjmp/longjmp are ran at run-time, not during lexical analysis by the compiler during compilation time.
	○ In some cases, due to compiler optimizations, because setjmp/longjmp may not store all relevant register values, could lead to wrong values being returned after a longjmp.
	○ Any local variables that the compiler does optimizations for (which may include code REORGANIZATION, which explains the /proc/setjmp_vars.c result to some degree), and most commonly Pointer variables and simple types such as char, int, float, and long are vulnerable.
		• Declare each local variable that may be impacted by setjmp/longjmp as "VOLATILE" to tell the compiler NOT to do optimizations for it.
	○ See /proc/setjmp_vars.c
    * You should generally avoid using set/longjmp due to po
</code></pre></div></div>]]></content><author><name></name></author><category term="tlpi" /><summary type="html"><![CDATA[6.1 6.2 6.3 Memory Layout of a Process 6.4 Virtual Memory Management 6.6 Command Line Arguments 6.7 Environment List 6.8 Performing a Non Local GoTo 6 1 • A program on disk consists of the following: 1. Binary identification. i. What file-format it is. On Linux, ELF (Executable &amp; Linking format). 2. Machine instructions. 3. Location of entry-point (main function). 4. Data/constants/strings. 5. Names of variables/functions. 6. Shared libraries. 7. Other information on how to construct a process. • Kernel data structures involved in maintaining a process: ○ Virtual memory table/information. ○ File descriptor table. ○ Signal handling information. ○ Resource usage/limits. 6 2 • Process ID (PID). • Pid_t Getpid(void). ○ Pid_t is an integer type. • Maximum process ID number is 32,767. This is defined as a PID_MAX macro in Linux kernel. • The PID number can be increased via /proc/sys/kernel/pid_max file. • When the maximum PID number is reached, it begins from a low number again (PID 300, not PID 1, because PID 1 - 300 are often used by system daemons and processes). • Pid_t getppid(void) - gets parent PID. ○ See family tree of processes with pstree. 6 3 Memory Layout of a Process • The layout: 1. Machine instructions. Each process-instance of the program points to these machine instructions (and initialized/uninitialized data segments, described below). 2. Initialized data segments. Explicitly declared variables. i. E.g. int I = 10; 3. Uninitialized data segments, e.g. int I;. Not explicitly declared variables. 4. Stack. i. Each new function call gets a stack frame in the stack. ii. Contains the function's local variables, parameters and return value. 5. Heap. i. For dynamically allocating memory. • (Un)initialized data in main() function get stored in the (un)initialized data segments (and not main()'s stack frame), whereas such data in another function get stored in the stack frame of that function. • Application Binary Interface (ABI) - set of rules for communication. A binary executable informs kernel/some library on how they should exchange certain important information. The ABI tells the kernel which registers and stack locations it will use to exchange this information. • Extern char etext, edata, end. ○ Extern char etext is the next byte after the end of the program text/code/instructions. ○ Edata is the unintiialized data segment. ○ End is the init data segment. 6 4 Virtual Memory Management • Locality of reference ○ Temporal locality § A program will use the same information again if it used it recently ○ Spatial locality § A program will use information close to information it recently used • RAM is divided into page frames • Virtual memory is divided into pages as well • Page size on Linux x86-32 = 4096 bytes • Swap ○ Can be used to store additional, unused pages. § If a process requests a page that happens to be in swap, page fault occurs: kernel must pause the process's execution and fetch the page(s). • Each process has a virtual page table. ○ Each element in the virtual page table points to a page in virtual address memory. § Each of these elements in turn point to either physical RAM memory where the page is stored, or indicate that the page is on disk. ○ If a process tries to access an element in the virtual page table that does not exist, a SIGSEGV signal is sent. § Unusued memory do not have to be added as entries in the virtual page table. • 4 situations when virtual address space of a process can change as kernel allocates/deallocates memory: ○ Stack grows downward ○ Heap grows ○ System-V related things ○ Mmap() or munmap() is used • There are 3 main benefits to mapping virtual addresses' of processes to physical RAM memory: ○ Isolation § A process only has access to the physical RAM pages that are mapped to that process's page table. ○ Memory sharing § Processes can share code, data, without duplicating it. ○ Memory protection § You can have different access privileges set for different processes for the same data. □ e.g. read for pid7, read-write for pid10. • Stack starts at high address, and grows downward. ○ Whenever a function call or global/main variable declaration is made, a stack frame is added. ○ There's a register that keeps track of the current "top" of the stack, i.e. the end of the stack in the direction it grows in. • Kernel memory/stack at beginning of each process ○ If that user process makes a syscall, kernel can use this separate stack to add function calls. • Functions use a program counter CPU register to keep track of which machine instructions to execute next. ○ If another function is called, the new stack frame of the called function includes this machine instruction so that it can be saved, so that once the called function returns, the original function knows what to do. 6 6 Command Line Arguments • Argc/argv • Argv[0] is the name of the program ○ The program can check the name used when calling it by looking at argv[0] ○ The program can then have different behavior if for example the user called gzip as opposed to gunzip. • The array of elements is terminated by a NULL-byte char, i.e. argv[argc] is NULL. ○ Each string in argv[] is also null-terminated. • Non-portable method of accessing commandline arguments on Linux: ○ /proc/PID/cmdline ○ Or /proc/self/cmdline if the process is getting its own cmdline args. • ARG_MAX value, i.e. total number of bytes that can be supplied via args. ○ Total space for argv and environ (env variables sorta) can be specified with RLIMIT_STACK resource limit. 6 7 Environment List • Children inherit parent data • Environment variables: name=value pairs. • Export SHELL=/bin/sh ○ This is an example of an env var ○ Printenv to see a list of all env vars ○ Env list of any process can be found at /proc/PID/environ • Accessing the environment from a C program ○ **environ points to an array, where each element points to the environment variables ○ Stepping through this array is done with pointers, even though it's an array. § Reason being that there is no argc value that specifies the size of the environ array. ○ Getenv(name) returns point to the value of an environment variable name § THIS IS PORTABLE!! ○ You can also make changes to environment variables with putenv() and setenv(). § Use case: when you use fork() to create child processes, you want the child processes to also have this modified environment. ○ Executing SUID (set-used-ID) programs securely may require using clearenv() to clear all env vars first. ○ When you call setenv(), a memory buffer is allocated to store the name=value pair. § If a program repeatedly calls setenv() and clearenv(), this memory buffer does NOT get free'd. □ This could lead to memory leaks. □ In practice, it does not, because programs tend to use clearenv() only on startup. 6 8 Performing a Non Local GoTo • Nonlocal goto means going from e.g. a function to some other memory area outside of the function. • Caveat: you cannot goto another function from a current function using goto, but you CAN using setjmp() and longjmp(). • Example use case: ○ Imagine multiple functions being called in a stack. ○ Each called function supplies its caller with a status value. ○ If an error status occurs at any stage, to go back to a normally executing function, we might have to pop several function calls from the stack. § Instead of going one by one, we can use the setjmp() and longjmp() commands to directly jump back to an OK function. • C does not allow for nested functions e.g. where you define X() then within X() you define Y(). So compiler has no way of knowing if Y is on the stack if a goto is written in X(). Pascal for example allows for this nesting and can thus in certain scenarios determine that a goto is possible. • Jump calls: ○ Setjmp(jmp_buf env); § Returns 0 on initial return, val when a longjmp() returns to setjmp() ○ Longjmp(jmp_buf env, int val); § Val specifies a value to supply the setjmp() with. That way, you can use val to distinguish which part of the program called setjmp(). If val is set to 0, it is automatically changed to 1 to avoid being misinterpreted as being the default 0. ○ Env stores the following: 1. Stack pointer register (that points to the top of the stack) (so it can "erase" unneeded function calls by simply moving the pointer to the same place it was when setjmp() was declared when longjmp() is called, accomplishing our intended purpose) 2. Program counter register (so it knows where setjmp() was executing from) • Env usually declared as a global var (or, less commonly, passed as function param) ○ There are restrictions specified by SUSv3 and C99 on when setjmp() can be used. Examples include: • If/while/switch • Etc • S = setjmp(env); is not standards conformant □ Somehow cannot guarantee setjmp() in this way has all the necessary info to save register values and the full stack. • Abusing longjmp() 1. Declare global buffer env. 2. Inside x(), setjmp(). 3. x() returns. 4. y() calls longjmp() to the setjmp() inside x(). • PROBLEM: x() is NOT on the stack! Chaos ensues. Program crash or infinite call-return loop, where the program thinks it's returning from a legitimate call. • Setjmp/longjmp are ran at run-time, not during lexical analysis by the compiler during compilation time. ○ In some cases, due to compiler optimizations, because setjmp/longjmp may not store all relevant register values, could lead to wrong values being returned after a longjmp. ○ Any local variables that the compiler does optimizations for (which may include code REORGANIZATION, which explains the /proc/setjmp_vars.c result to some degree), and most commonly Pointer variables and simple types such as char, int, float, and long are vulnerable. • Declare each local variable that may be impacted by setjmp/longjmp as "VOLATILE" to tell the compiler NOT to do optimizations for it. ○ See /proc/setjmp_vars.c * You should generally avoid using set/longjmp due to po]]></summary></entry><entry><title type="html">The Linux Programming Interface Chapter 7 Memory Allocation Summary</title><link href="http://localhost:4000/tlpi/2023/05/22/tlpi-ch7.html" rel="alternate" type="text/html" title="The Linux Programming Interface Chapter 7 Memory Allocation Summary" /><published>2023-05-22T00:00:00+02:00</published><updated>2023-05-22T00:00:00+02:00</updated><id>http://localhost:4000/tlpi/2023/05/22/tlpi-ch7</id><content type="html" xml:base="http://localhost:4000/tlpi/2023/05/22/tlpi-ch7.html"><![CDATA[<p><img src="/docs/assets/images/tlpi-ch7/tlpi-ch7-1.jpg" alt="Image" /></p>

<p><img src="/docs/assets/images/tlpi-ch7/tlpi-ch7-2.jpg" alt="Image" /></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>• Heap is a contiguous region in memory
	○ Malloc() to allocate memory
		§ Malloc() builds upon brk() and sbrk()
			□ These are called so because they change the "program break", i.e. the current limit of the heap.
	○ Simply adjust program break to adjust the size of the heap
	○ PHYSICAL MEMORY is NOT allocated UNTIL the program tries to ACCESS the newly allocated memory
• Brk(end_segment)
	○ Set the program break
	○ This gets rounded up to nearest page boundary, as allocation happens in pages.
	○ Restrictions on max size based on multiple factors, such as location of various other memory sets (shared libaries, stack etc).
• Sbrk(increment)
	○ Sbrk(1) increases the heap by 1 page.
	○ Its return value is the old program break; which is the START of the newly allocated page.
	○ Sbrk(0) simply returns the current program break; this can also be useful.
• Void Malloc(size)
	○ Does not allocate memory until used
	○ Maintains a list so we can free() unused memory
	○ Returns pointer pointing to the newly allocated memory
	○ Is on a BYTE BOUNDARY, so appropriate for any char/int/data type we wish to assign there (efficient access).
• Free(pointer)
	○ Adds the memory block to a "free" list.
		§ Note that program break cannot simply be reduced; free'd memory is usually in the middle of the heap.
		§ Another reason is that the program will likely use that memory in the future anyway, so no need to reduce heap size.
• Memalloc/free_and_sbrk.c example
	○ In essence, the program break remains the same before and after free().
	○ However, if free() is used at memory regions at the top end of the heap, then the program break is actually decreased.
		§ The reason for this is that the glibc free() function checks if free'd memory is adjacent, and if it is, it groups them into one big block of free memory.
			□ This is to ensure that we do not have a bunch of small free sets of memory, which might not be able to satisfy a future call to malloc() depending on the size passed to malloc().
• Free() caveats
	○ Upon program termination, all allocated memory is returned to the system (i.e. automatically free'd).
	○ It still might be good to use free even though your program will terminate (and is not a continuously running system e.g. a web server):
		§ Makes code more readable &amp; maintainable, so you understand what memory has been free'd and is thus no longer in use.
		§ Identifying REAL memory leaks: any unfree'd memory will be reported as a memory leak.
• Implementation of malloc and free
	○ Malloc implementation
		§ It first checks the free list.
			□ If memory with the required size is available, it takes just as much as it needs and allocates it.
		§ Else, it uses sbrk() to allocate memory; usually some multiple of the virtual memory page size, then adds it to the free list.
			□ Malloc can now allocate this memory from the free list.
	○ Free implementation
		§ Malloc() includes a length of block, and returns pointer as suggested by the image on the right.
		§ Free list includes length of block, pointer to previous and next free blocks, and then the free memory.
		§ Secure programming:
			□ If the length value is accidentally incremented, then the block is deallocated, but then re-allocated, then the program thinks it has 2 distinct memory blocks, but the first one actually overlaps with the adjacent one. See the image in red to the right.
			□ Prevention:
				® Always free unused memory to avoid memory leaks in daemon/long-running processes.
				® Always free memory with a pointer returned by malloc and do not modify it.
				® Do not free memory twice.
• Malloc debugging
	○ Mtrace() and muntrace()
		§ MALLOC_TRACE environment var should also be set
		§ Writes log output to a file and runs scripts to interpret these logs
	○ Mcheck() and mprobe()
		§ Probes allocated memory regions; checks if your code is trying to read/write out of bounds.
	○ Only use the malloc() package with debugging features in dev environment; turn them off in production (i.e. use the regular malloc package in C standard library)
		§ This is because debugging malloc package takes more memory, slower run-time etc.
	○ Other tools: Valgrind and Insure++
	○ Mallopt()
		§ Use this function to set configuration parameters for malloc()
		§ Such configuration parameters might be:
			□ How much free memory needs to exist at the top of the heap before sbrk() is called to reduce heap size.
• Other heap memory allocation methods
	○ Calloc(numitems, size)
		§ Allocates memory for a set number of items that each have the same fixed size
	○ Realloc(ptr, size)
		§ Given a pointer to an existing allocated block of memory, realloc resizes that memory block to size.
		§ Assuming the requested size is greater than the current size:
			□ If there is enough adjacent memory available, it is allocated.
			□ If the memory block being resized is at the top end of the heap, the program break is extended.
			□ If the memory block is in the middle of the heap and there is not enough adjacent memory available, a new memory block is allocated (either from the free list or at the top end of the heap) and all data is copied from old block to new block.
				® Very CPU-intensive. Use very sparingly.
	○ Memalign(size_t boundary, size_t size)
		§ Allocates size bytes starting at an address aligned to a multiple of boundary (which must be a power of two)
• Allocating memory on the stack
	○ Alloca(size_t)
		§ Allocates data on the stack
			□ Does this by moving the stack pointer further up
		§ Do NOT use free() or realloc() on this data
			□ The data will be freed automatically when the function that called alloca() returns
			□ Realloc() will ruin the stack frames of subsequent function calls
		§ Especially useful with longjmp()
			□ If you use malloc() and you use longjmp() to handle a signal to jump back to some previous function, any malloc()'d memory will not be free'd. But, if you used alloca(), then as the functions return, they will automatically free their alloca()'d memory.
	○ You must y = alloca() and not func(x, alloca(), z)
		§ Doing so would put the allocated memory in the function parameter space of the stack frame.
</code></pre></div></div>

<p><img src="/docs/assets/images/tlpi-ch7/tlpi-ch7-3.jpg" alt="Image" /></p>

<p><img src="/docs/assets/images/tlpi-ch7/tlpi-ch7-4.png" alt="Image" /></p>]]></content><author><name></name></author><category term="tlpi" /><summary type="html"><![CDATA[• Heap is a contiguous region in memory ○ Malloc() to allocate memory § Malloc() builds upon brk() and sbrk() □ These are called so because they change the "program break", i.e. the current limit of the heap. ○ Simply adjust program break to adjust the size of the heap ○ PHYSICAL MEMORY is NOT allocated UNTIL the program tries to ACCESS the newly allocated memory • Brk(end_segment) ○ Set the program break ○ This gets rounded up to nearest page boundary, as allocation happens in pages. ○ Restrictions on max size based on multiple factors, such as location of various other memory sets (shared libaries, stack etc). • Sbrk(increment) ○ Sbrk(1) increases the heap by 1 page. ○ Its return value is the old program break; which is the START of the newly allocated page. ○ Sbrk(0) simply returns the current program break; this can also be useful. • Void Malloc(size) ○ Does not allocate memory until used ○ Maintains a list so we can free() unused memory ○ Returns pointer pointing to the newly allocated memory ○ Is on a BYTE BOUNDARY, so appropriate for any char/int/data type we wish to assign there (efficient access). • Free(pointer) ○ Adds the memory block to a "free" list. § Note that program break cannot simply be reduced; free'd memory is usually in the middle of the heap. § Another reason is that the program will likely use that memory in the future anyway, so no need to reduce heap size. • Memalloc/free_and_sbrk.c example ○ In essence, the program break remains the same before and after free(). ○ However, if free() is used at memory regions at the top end of the heap, then the program break is actually decreased. § The reason for this is that the glibc free() function checks if free'd memory is adjacent, and if it is, it groups them into one big block of free memory. □ This is to ensure that we do not have a bunch of small free sets of memory, which might not be able to satisfy a future call to malloc() depending on the size passed to malloc(). • Free() caveats ○ Upon program termination, all allocated memory is returned to the system (i.e. automatically free'd). ○ It still might be good to use free even though your program will terminate (and is not a continuously running system e.g. a web server): § Makes code more readable &amp; maintainable, so you understand what memory has been free'd and is thus no longer in use. § Identifying REAL memory leaks: any unfree'd memory will be reported as a memory leak. • Implementation of malloc and free ○ Malloc implementation § It first checks the free list. □ If memory with the required size is available, it takes just as much as it needs and allocates it. § Else, it uses sbrk() to allocate memory; usually some multiple of the virtual memory page size, then adds it to the free list. □ Malloc can now allocate this memory from the free list. ○ Free implementation § Malloc() includes a length of block, and returns pointer as suggested by the image on the right. § Free list includes length of block, pointer to previous and next free blocks, and then the free memory. § Secure programming: □ If the length value is accidentally incremented, then the block is deallocated, but then re-allocated, then the program thinks it has 2 distinct memory blocks, but the first one actually overlaps with the adjacent one. See the image in red to the right. □ Prevention: ® Always free unused memory to avoid memory leaks in daemon/long-running processes. ® Always free memory with a pointer returned by malloc and do not modify it. ® Do not free memory twice. • Malloc debugging ○ Mtrace() and muntrace() § MALLOC_TRACE environment var should also be set § Writes log output to a file and runs scripts to interpret these logs ○ Mcheck() and mprobe() § Probes allocated memory regions; checks if your code is trying to read/write out of bounds. ○ Only use the malloc() package with debugging features in dev environment; turn them off in production (i.e. use the regular malloc package in C standard library) § This is because debugging malloc package takes more memory, slower run-time etc. ○ Other tools: Valgrind and Insure++ ○ Mallopt() § Use this function to set configuration parameters for malloc() § Such configuration parameters might be: □ How much free memory needs to exist at the top of the heap before sbrk() is called to reduce heap size. • Other heap memory allocation methods ○ Calloc(numitems, size) § Allocates memory for a set number of items that each have the same fixed size ○ Realloc(ptr, size) § Given a pointer to an existing allocated block of memory, realloc resizes that memory block to size. § Assuming the requested size is greater than the current size: □ If there is enough adjacent memory available, it is allocated. □ If the memory block being resized is at the top end of the heap, the program break is extended. □ If the memory block is in the middle of the heap and there is not enough adjacent memory available, a new memory block is allocated (either from the free list or at the top end of the heap) and all data is copied from old block to new block. ® Very CPU-intensive. Use very sparingly. ○ Memalign(size_t boundary, size_t size) § Allocates size bytes starting at an address aligned to a multiple of boundary (which must be a power of two) • Allocating memory on the stack ○ Alloca(size_t) § Allocates data on the stack □ Does this by moving the stack pointer further up § Do NOT use free() or realloc() on this data □ The data will be freed automatically when the function that called alloca() returns □ Realloc() will ruin the stack frames of subsequent function calls § Especially useful with longjmp() □ If you use malloc() and you use longjmp() to handle a signal to jump back to some previous function, any malloc()'d memory will not be free'd. But, if you used alloca(), then as the functions return, they will automatically free their alloca()'d memory. ○ You must y = alloca() and not func(x, alloca(), z) § Doing so would put the allocated memory in the function parameter space of the stack frame.]]></summary></entry><entry><title type="html">The Linux Programming Interface Chapter 8 Users and Groups Summary</title><link href="http://localhost:4000/tlpi/2023/05/22/tlpi-ch8.html" rel="alternate" type="text/html" title="The Linux Programming Interface Chapter 8 Users and Groups Summary" /><published>2023-05-22T00:00:00+02:00</published><updated>2023-05-22T00:00:00+02:00</updated><id>http://localhost:4000/tlpi/2023/05/22/tlpi-ch8</id><content type="html" xml:base="http://localhost:4000/tlpi/2023/05/22/tlpi-ch8.html"><![CDATA[<p>Users and Groups</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>• /etc/passwd
	○ Login name:encrypted password:
	○ Login name
		§ There's both a UID and a user name.
	○ Encrypted password:
		§ 13 char encrypted password.
		§ If shadow passwords are enabled; this is just an "x"
			□ Encrypted password stored in shadow file
		§ If empty; no password required for this account.
	○ Numeric ID for user
		§ 0 = root
		§ Max number of IDs is 2^32 in Linux 2.4 and later
		§ Can have multiple users with the same ID but different username:password combinations
			□ Can have different file permissions for the different users
	○ Group ID
	○ Comment
		§ Information about the user
	○ Home directory
		§ Directory the user will be placed in after logging in
	○ Login shell
		§ The program that will take over upon login; e.g. /bin/bash
	○ On networked systems, password information might be stored on remote servers (e.g. with LDAP use)
		§ But on stand-alone systems, password info is in /etc/passwd.
• /etc/shadow
	○ Only privileged programs have access to this
	○ Stores other security info beyond just encrypted passwords
• /etc/group
	○ Group ID is stored in the password entry for the user
		§ Additional group ID's the user belongs to are stored in /etc/group
			□ Reason is historical: in early UNIX systems, a user could only belong to one group. Upon extending this, additional group memberships were noted in /etc/group.
	○ Organization:
		§ Group name
		§ Encrypted password
			□ With multi-group memberships, passwords for groups are rarely used now.
			□ In a shell session, user is prompted for group password before the shell session continues for that user with that group membership.
			□ /etc/gshadow if shadowed passwords enabled for groups
		§ Group ID (2^32)
		§ User list
	○ Examples:
		§ In /etc/passwd:
			□ Userjohn:x:1001:100:John:/home/john:/bin/bash
		§ In /etc/group:
			□ Users:x:100
			□ Staff:x:101:usersarah, userjimmy, userjohn
			□ Teach:x:104:usersarah, userjohn
		§ Userjohn belongs to users, staff and teach.
• Retrieving user and group info
	○ Getpwnam() and getpwuid() get information from the /etc/passwd file based on username or user ID.
		§ These return a pointer to a statically allocated struct that contains the password file information for that user.
			□ If these are called again, the statically allocated struct is overwritten.
			□ You can use getpwuid_r and other similar functions that end with _r (which indicate "re-entrancy"), meaning you can copy the password file data to a separate buffer that you can save.
	○ Getgrpnam(), getgrgid() to get group information based on name/ID.
	○ UserIdFromName() etc
		§ Conversion functions from user/group ID to name or vice versa.
	○ Getpwent()
		§ Can use this in a while loop to go through all info in the passwd file
		§ Use endpwent() so that if another part of your code uses getpwent(), it will start from the beginning of the passwd file.
		§ Corresponding functions for group info.
	○ Getspnam() get info from shadow password file.
• Password encryption and user auth
	○ Application COULD have its own DB to store username:password combinations.
	○ But imagine networked applications like SSH, FTP, etc
		§ These use UNIX username:password combos
	○ Checking passwords in UNIX uses a one-way hashing encryption algorithm.
	○ Crypt(key, salt)
		§ DES algorithm
		§ Returns 13-char encrypted password
• Check_password example
	○ A user tries to log in by supplying their username
	○ Program fetches the corresponding encrypted password from /etc/shadow (if shadowed passwords are enabled, otherwise directly from /etc/passwd) (if shadowed, the program must run with privileges)
	○ Use getpass() to prompt the user for their password
		§ Getpass() turns off terminal echoing, so no characters are shown on the screen when typing the password
	○ Use crypt() to check if the supplied password is the same as the encrypted password in the shadow file.
	○ Important security point:
		§ Directly after encrypting the user-supplied password, instantly remove the unencrypted user-supplied password from memory by overwriting it, such as in the following way:
			□ For (p=password; p* != '\0';) {
*p++ = '\0'; }
</code></pre></div></div>]]></content><author><name></name></author><category term="tlpi" /><summary type="html"><![CDATA[Users and Groups • /etc/passwd ○ Login name:encrypted password: ○ Login name § There's both a UID and a user name. ○ Encrypted password: § 13 char encrypted password. § If shadow passwords are enabled; this is just an "x" □ Encrypted password stored in shadow file § If empty; no password required for this account. ○ Numeric ID for user § 0 = root § Max number of IDs is 2^32 in Linux 2.4 and later § Can have multiple users with the same ID but different username:password combinations □ Can have different file permissions for the different users ○ Group ID ○ Comment § Information about the user ○ Home directory § Directory the user will be placed in after logging in ○ Login shell § The program that will take over upon login; e.g. /bin/bash ○ On networked systems, password information might be stored on remote servers (e.g. with LDAP use) § But on stand-alone systems, password info is in /etc/passwd. • /etc/shadow ○ Only privileged programs have access to this ○ Stores other security info beyond just encrypted passwords • /etc/group ○ Group ID is stored in the password entry for the user § Additional group ID's the user belongs to are stored in /etc/group □ Reason is historical: in early UNIX systems, a user could only belong to one group. Upon extending this, additional group memberships were noted in /etc/group. ○ Organization: § Group name § Encrypted password □ With multi-group memberships, passwords for groups are rarely used now. □ In a shell session, user is prompted for group password before the shell session continues for that user with that group membership. □ /etc/gshadow if shadowed passwords enabled for groups § Group ID (2^32) § User list ○ Examples: § In /etc/passwd: □ Userjohn:x:1001:100:John:/home/john:/bin/bash § In /etc/group: □ Users:x:100 □ Staff:x:101:usersarah, userjimmy, userjohn □ Teach:x:104:usersarah, userjohn § Userjohn belongs to users, staff and teach. • Retrieving user and group info ○ Getpwnam() and getpwuid() get information from the /etc/passwd file based on username or user ID. § These return a pointer to a statically allocated struct that contains the password file information for that user. □ If these are called again, the statically allocated struct is overwritten. □ You can use getpwuid_r and other similar functions that end with _r (which indicate "re-entrancy"), meaning you can copy the password file data to a separate buffer that you can save. ○ Getgrpnam(), getgrgid() to get group information based on name/ID. ○ UserIdFromName() etc § Conversion functions from user/group ID to name or vice versa. ○ Getpwent() § Can use this in a while loop to go through all info in the passwd file § Use endpwent() so that if another part of your code uses getpwent(), it will start from the beginning of the passwd file. § Corresponding functions for group info. ○ Getspnam() get info from shadow password file. • Password encryption and user auth ○ Application COULD have its own DB to store username:password combinations. ○ But imagine networked applications like SSH, FTP, etc § These use UNIX username:password combos ○ Checking passwords in UNIX uses a one-way hashing encryption algorithm. ○ Crypt(key, salt) § DES algorithm § Returns 13-char encrypted password • Check_password example ○ A user tries to log in by supplying their username ○ Program fetches the corresponding encrypted password from /etc/shadow (if shadowed passwords are enabled, otherwise directly from /etc/passwd) (if shadowed, the program must run with privileges) ○ Use getpass() to prompt the user for their password § Getpass() turns off terminal echoing, so no characters are shown on the screen when typing the password ○ Use crypt() to check if the supplied password is the same as the encrypted password in the shadow file. ○ Important security point: § Directly after encrypting the user-supplied password, instantly remove the unencrypted user-supplied password from memory by overwriting it, such as in the following way: □ For (p=password; p* != '\0';) { *p++ = '\0'; }]]></summary></entry><entry><title type="html">The Linux Programming Interface Chapter 9 Process Credentials Summary</title><link href="http://localhost:4000/tlpi/2023/05/22/tlpi-ch9.html" rel="alternate" type="text/html" title="The Linux Programming Interface Chapter 9 Process Credentials Summary" /><published>2023-05-22T00:00:00+02:00</published><updated>2023-05-22T00:00:00+02:00</updated><id>http://localhost:4000/tlpi/2023/05/22/tlpi-ch9</id><content type="html" xml:base="http://localhost:4000/tlpi/2023/05/22/tlpi-ch9.html"><![CDATA[<p>Process Credentials</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>• Processes have user ID/group ID credentials attached to them.
	○ You can have programs that, when run, have the privileges of the UID/GID attached to it.
	○ It can also be used to control who has access to the processes/programs, etc.
• Real User ID/Group ID
	○ For example, when a user logs in and /bin/bash is set to run in the /etc/passwd file, the /bin/bash process gets the user ID and group ID from the /etc/passwd as its real UID/GID.
• Effective User/Group ID
	○ Determines the privileges of a process when it comes to syscalls, file access etc.
		§ Files have associated users/groups, i.e. the owner of the file.
		§ Thus, the process's effective UID/GID may determine if it has access to that file.
	○ Effective is usually same as Real, but can be different in Set-user-ID and set-group-ID programs.
• Set-User-ID programs
	○ Unprivileged users can set the set-user-ID and set-group-ID bits on files they own.
		§ Privileged users can do it on any files.
	○ Of interest are executable files.
		§ Setting the set-user-ID bit on an executable file to 1.
			□ When a process now executes that file (i.e. loads it into the process's memory), the effective UID (or GID) of the process is set to the same as the executable file being executed.
			□ This gives the process privileges it normally would not have.
	○ For instance; if an executable file is owned by root and the set-user-ID bit is set; a process executing that file does so with superuser/root privileges.
	○ It is possible to create a separate user account =&gt; assign it privileges to a system resource (file or other resource) =&gt; set the set-user-ID bit =&gt; now a process that executes it gets the effective user ID of that newly created account, and doesn't have to get root privileges. More secure!
	○ Set-User-ID programs include:
		§ Passwd
		§ Su
		§ Mount/umount
	○ Set-Group-ID program wall()
		§ Broadcasts a message to all terminals
		§ All terminals belong to the tty group by default
	○ For instance, the check_password program we wrote before, that takes some user input and checks the shadow password file, and uses crypt() to check if they are the same.
		§ You can set the owner of the check_password executable program using "chown" to be root.
		§ You can then set the set-user-ID bit to 1.
		§ Now when check_password is run, its effective User ID will be set to 0 (i.e. root) and it will have access to /etc/shadow passwords and will be able to use crypt() to compare user-supplied password.
• Saved User IDs
	○ Imagine a running process that has real_uid = effective_uid = saved_uid = 1000.
	○ Imagine this process executes a file that has the set_user_ID set to 0 (root). The process now has:
	○ Real_uid = 1000. effective_uid = saved_uid = 0.
	○ There are syscalls the process can then use to switch its effective UID between real and saved UID, only taking elevated privileges as it needs them.
• File system UID/GID determines a process's permissions to access files.
	○ Effective UID's take part in determining if a process can send/receive signals.
	○ If for example NFS (Network File System) changes its effective UID to access certain files the client process needs to access, then unprivileged users could potentially exploit this by sending signals to NFS.
	○ File-system UID's were devised to make this separation; now NFS can access files belonging to a client process without opening up the vulnerability of being sent signals by unprivileged processes.
	○ After Linux 2.0, the effective user ID no longer permits an unprivileged process to send signals to another. So, this is no longer an issue, really. The file-system ID feature is no longer necessary, either.
• Supplementary group IDs
	○ Set of additional groups to which a process belongs
	○ In conjunction with effective and file-system IDs, determines which System V interprocess communication (IPC) permissions it has, which files it can access, and other system resources.
• Retrieving and Modifying Process Credentials
	○ In /proc/PID/status, you can find the UIDs and GIDs associated with the process, in the order:
		§ Real ID, effective ID, saved ID, file-system ID
	○ Getuid(), geteuid(), getgid(), getegid()
		§ Get real and effective user/group ID's with these syscalls.
	○ Setuid/setgid
		§ Set the UID/GID of the process.
		§ If an unprivileged process calls this, it can only change to a value that is the same as its real, effective or saved UID. If executing a non-privileged program, this means the unprivileged process can't do anything meaningful with this syscall. It's only useful if executing a SUID binary.
		§ If a privileged process calls this, e.g. root (0) and sets its value to 3, then it permanently loses all its superuser privileges and cannot go back to root (0).
			□ This is only relevant for setuid(), not setgid().
	○ Seteuid/setegid
		§ Set effective user ID specifically.
		§ Privileged process could set its effective ID to something else then regain root privileges by using seteid to set it back to 0, i.e. the same as its real ID.
	○ Setreuid/setregid
		§ Set the real and effective user IDs. First parameter is real ID, second parameter is effective ID.
		§ An unprivileged process can only change the effective ID to the current Real or Saved ID.
		§ A privileged process can change the real and effective ID as it pleases.
		§ If an (un)privileged process changes the effective ID, the saved ID is also changed.
		§ If a privileged process changes the effective ID to the real ID, the saved ID remains unchanged. If the effective ID is set to any other ID than the real ID, the saved ID is also changed to the same ID as the new effective ID.
	○ Setresuid/setresgid
		§ 3 parameters: real, effective and saved ID.
		§ Unprivileged process can only change IDs that it already has as real, effective and saved.
		§ Privileged process can change as it likes.
		§ Specifying -1 for one of the parameters does not change it.
		§ All or nothing: either all changes are successful or none are.
		§ May not be portable; not specified in SUSv3, even though it's the most straight-forward.
		§ File-system ID is set to the effective ID.
	○ Setfsuid/setfsgid
		§ Set file-system ID
	○ Initgroups()
		§ Gets a user's groups from /etc/group
		§ Usually employed by programs that log a user in
			□ Supplementary group IDs retrieved from /etc/group
</code></pre></div></div>

<p><img src="/docs/assets/images/tlpi-ch9/tlpi-ch9-1.jpg" alt="Image" /></p>]]></content><author><name></name></author><category term="tlpi" /><summary type="html"><![CDATA[Process Credentials • Processes have user ID/group ID credentials attached to them. ○ You can have programs that, when run, have the privileges of the UID/GID attached to it. ○ It can also be used to control who has access to the processes/programs, etc. • Real User ID/Group ID ○ For example, when a user logs in and /bin/bash is set to run in the /etc/passwd file, the /bin/bash process gets the user ID and group ID from the /etc/passwd as its real UID/GID. • Effective User/Group ID ○ Determines the privileges of a process when it comes to syscalls, file access etc. § Files have associated users/groups, i.e. the owner of the file. § Thus, the process's effective UID/GID may determine if it has access to that file. ○ Effective is usually same as Real, but can be different in Set-user-ID and set-group-ID programs. • Set-User-ID programs ○ Unprivileged users can set the set-user-ID and set-group-ID bits on files they own. § Privileged users can do it on any files. ○ Of interest are executable files. § Setting the set-user-ID bit on an executable file to 1. □ When a process now executes that file (i.e. loads it into the process's memory), the effective UID (or GID) of the process is set to the same as the executable file being executed. □ This gives the process privileges it normally would not have. ○ For instance; if an executable file is owned by root and the set-user-ID bit is set; a process executing that file does so with superuser/root privileges. ○ It is possible to create a separate user account =&gt; assign it privileges to a system resource (file or other resource) =&gt; set the set-user-ID bit =&gt; now a process that executes it gets the effective user ID of that newly created account, and doesn't have to get root privileges. More secure! ○ Set-User-ID programs include: § Passwd § Su § Mount/umount ○ Set-Group-ID program wall() § Broadcasts a message to all terminals § All terminals belong to the tty group by default ○ For instance, the check_password program we wrote before, that takes some user input and checks the shadow password file, and uses crypt() to check if they are the same. § You can set the owner of the check_password executable program using "chown" to be root. § You can then set the set-user-ID bit to 1. § Now when check_password is run, its effective User ID will be set to 0 (i.e. root) and it will have access to /etc/shadow passwords and will be able to use crypt() to compare user-supplied password. • Saved User IDs ○ Imagine a running process that has real_uid = effective_uid = saved_uid = 1000. ○ Imagine this process executes a file that has the set_user_ID set to 0 (root). The process now has: ○ Real_uid = 1000. effective_uid = saved_uid = 0. ○ There are syscalls the process can then use to switch its effective UID between real and saved UID, only taking elevated privileges as it needs them. • File system UID/GID determines a process's permissions to access files. ○ Effective UID's take part in determining if a process can send/receive signals. ○ If for example NFS (Network File System) changes its effective UID to access certain files the client process needs to access, then unprivileged users could potentially exploit this by sending signals to NFS. ○ File-system UID's were devised to make this separation; now NFS can access files belonging to a client process without opening up the vulnerability of being sent signals by unprivileged processes. ○ After Linux 2.0, the effective user ID no longer permits an unprivileged process to send signals to another. So, this is no longer an issue, really. The file-system ID feature is no longer necessary, either. • Supplementary group IDs ○ Set of additional groups to which a process belongs ○ In conjunction with effective and file-system IDs, determines which System V interprocess communication (IPC) permissions it has, which files it can access, and other system resources. • Retrieving and Modifying Process Credentials ○ In /proc/PID/status, you can find the UIDs and GIDs associated with the process, in the order: § Real ID, effective ID, saved ID, file-system ID ○ Getuid(), geteuid(), getgid(), getegid() § Get real and effective user/group ID's with these syscalls. ○ Setuid/setgid § Set the UID/GID of the process. § If an unprivileged process calls this, it can only change to a value that is the same as its real, effective or saved UID. If executing a non-privileged program, this means the unprivileged process can't do anything meaningful with this syscall. It's only useful if executing a SUID binary. § If a privileged process calls this, e.g. root (0) and sets its value to 3, then it permanently loses all its superuser privileges and cannot go back to root (0). □ This is only relevant for setuid(), not setgid(). ○ Seteuid/setegid § Set effective user ID specifically. § Privileged process could set its effective ID to something else then regain root privileges by using seteid to set it back to 0, i.e. the same as its real ID. ○ Setreuid/setregid § Set the real and effective user IDs. First parameter is real ID, second parameter is effective ID. § An unprivileged process can only change the effective ID to the current Real or Saved ID. § A privileged process can change the real and effective ID as it pleases. § If an (un)privileged process changes the effective ID, the saved ID is also changed. § If a privileged process changes the effective ID to the real ID, the saved ID remains unchanged. If the effective ID is set to any other ID than the real ID, the saved ID is also changed to the same ID as the new effective ID. ○ Setresuid/setresgid § 3 parameters: real, effective and saved ID. § Unprivileged process can only change IDs that it already has as real, effective and saved. § Privileged process can change as it likes. § Specifying -1 for one of the parameters does not change it. § All or nothing: either all changes are successful or none are. § May not be portable; not specified in SUSv3, even though it's the most straight-forward. § File-system ID is set to the effective ID. ○ Setfsuid/setfsgid § Set file-system ID ○ Initgroups() § Gets a user's groups from /etc/group § Usually employed by programs that log a user in □ Supplementary group IDs retrieved from /etc/group]]></summary></entry><entry><title type="html">Core DevOps Concepts</title><link href="http://localhost:4000/devops/2023/05/22/devops-core.html" rel="alternate" type="text/html" title="Core DevOps Concepts" /><published>2023-05-22T00:00:00+02:00</published><updated>2023-05-22T00:00:00+02:00</updated><id>http://localhost:4000/devops/2023/05/22/devops-core</id><content type="html" xml:base="http://localhost:4000/devops/2023/05/22/devops-core.html"><![CDATA[<h1 id="components-of-devops">COMPONENTS OF DEVOPS</h1>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>• CI/CD
• Continuous monitoring/improvement
• IaC
• Configuration management
</code></pre></div></div>

<p><img src="/docs/assets/images/devops/devops-core/1.png" alt="Image" /></p>

<p><img src="/docs/assets/images/devops/devops-core/2.png" alt="Image" /></p>

<h1 id="continuous-integration--continuous-deployment">CONTINUOUS INTEGRATION / CONTINUOUS DEPLOYMENT</h1>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>• Continuous Integration (test DEV's code)
	○ Automate code testing
		1) Dev pushes code
		2) Automated build
		3) Automated unit/integration testing
• Continuous deployment (deploy to PROD)
	1) Dev pushes code
	2) Automated build
	3) Automated unit/integration testing
	4) Additional manual tests
	5) Provision resources
		§ IaC scripts
	6) Deploy
		• IaC scripts
	7) Monitor
	8) Rollback if necessary
		• Version control
</code></pre></div></div>

<p><img src="/docs/assets/images/devops/devops-core/3.png" alt="Image" /></p>

<h1 id="continuous-monitoringimprovement-metricskpi">CONTINUOUS MONITORING/IMPROVEMENT METRICS/KPI</h1>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>• Change volume
	○ Number of new lines of code
	○ Number of bug fixes
• Deployment frequency
	○ How often a team is deploying
	○ Should be consistent if mature software, upward trend if new
• Time from starting dev to deployment
• % of failed deployments
	○ Review in conjunction with change volume!
• Availability
	○ How many releases led to =&gt; violations of SLA?
	○ Average downtime?
• Customer complaint volume
• % change in user volume (sign-ups, log-ins)
</code></pre></div></div>

<h1 id="iac">IaC</h1>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>• Template-driven deployment
• Implement the following in an organization:
	○ Standardization
	○ Consistency
	○ Compliance
</code></pre></div></div>

<h1 id="configurationchangepatchvuln-management">CONFIGURATION/CHANGE/PATCH/VULN MANAGEMENT</h1>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>• Chef/Puppet/Ansible (tools to manage IaC)
	○ Automate sysadmin tasks including:
		▫ Provisioning of resources
		▫ Configuration &amp; management of IT resources
• Increase productivity
	○ Deploy to hundreds of resources simultaneously
• Decrease downtime (IMMUTABLE DEPLOYMENT) (PATCH/VULN MGMT)
	1) Update configuration on a subset of PROD machines
	2) Test live against a subset of users
	3) Gradually delete existing PROD machines and replace them with new machines with the new configuration
	4) Monitor this process continuously
</code></pre></div></div>

<h1 id="traditional-organizations">TRADITIONAL ORGANIZATIONS</h1>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>• Disconnect between operations (administrators) and developers
	○ They do not understand each other's needs
	○ Might use different tools/processes
		§ Devs might run their code on a certain OS build, whereas Ops 
        might deploy on a different, incompatible OS build
</code></pre></div></div>

<h1 id="benefits-of-devops">BENEFITS OF DEVOPS</h1>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>• Speed
	○ Quick to new releases
	○ Adapt to changing needs
• Fast delivery
	○ Automating end-to-end pipelines (dev, build, deployment)
• Reliability
	○ CI/CD for automated security testing
• Scalability
• Collaboration
	○ Shared responsibility model between Dev &amp; Ops
• Security
	○ Automate security checking of the frequent changes
</code></pre></div></div>

<h1 id="introducing-devsecops">INTRODUCING DEVSECOPS</h1>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>• Security automation &amp; at scale

1) Code: Scan all code for secret/access keys
2) Build: Tag security artifacts e.g. access tokens, encryption keys for easy ID
3) Test: Scan code for vulnerabilities, test security standards
4) Deploy: All security components should be in place. Checksums
5) Monitor: security standards, vulnerable dependencies, changing compliance regulations
</code></pre></div></div>

<h4 id="appsec-testing">AppSec Testing</h4>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>• Software composition analysis (SCA)
	○ Check for known vulns in dependencies (Snyk)
• SAST
	○ SonarQube, during coding (SonarLint)
• DAST
	○ Web app vuln scanner
	○ Black-box pentest against live system
• IAST
	○ App is run by automated test; simultaneously run vulnerability tests
</code></pre></div></div>

<p><img src="/docs/assets/images/devops/devops-core/4.png" alt="Image" /></p>

<h1 id="implementing-a-cd-strategy">IMPLEMENTING A CD STRATEGY</h1>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>• In-place deployment
	○ Deploy in one big sweet
	○ Full rollback only option to restore
	○ Low cost, fast to deploy
• Rolling deployment
	1) Divide servers into groups
	2) Deploy to 1 group at a time
	○ Achieve zero down-time, easy rollback
• Blue-green deployment
	○ Blue env: PROD
	○ Green env: new environment mimicking PROD
	○ Gradually divert more and more of  PROD traffic from blue to green (load balancing/canary analysis). 2 methods:
		1) DNS cutover
		2) Autoscaling
			• Replace existing servers with servers running new software version when autoscaling.
	○ Zero downtime, easy rollback
• Red-black deployment
	1) Canary testing: divert 1% of prod traffic to new red environment
	2) If all is OK, proceed.
	3) Set resources for red environment based on current usage in PROD
	4) DNS cutover from black (old PROD env) to new red env
	5) Rollback: return DNS to black (old PROV env)
	6) Use as Beta
• Immutable deployment
	○ Tear some servers down, spin up new ones, etc.
	○ Good for older app infrastructures with many patches over time
</code></pre></div></div>

<h1 id="continuous-testing-in-cicd-pipeline">Continuous testing in CI/CD pipeline</h1>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>• Unit tests 
	○ 70% of testing
	○ Conducted on programmer's PC
	○ Detect bugs
	○ Check: Code coverage, adherence to coding guidelines etc.
• Integration/System testing
	○ Testing environments that mimic PROD
	○ Costlier
	○ Different testing teams
	○ Regression testing (code coverage)
• User Acceptance Testing (UAT)
	○ Replica of PROD
	○ System/performance testing
• A/B &amp; Canary testing
	○ Final testing conducted in PROD
	○ A/B &amp; Canary Testing
		§ Divert % to new PROD systems
		§ Ask users what they think
		§ Collect feedback
		§ Adjust new PROD system accordingly
• Load testing of front-end, DB etc.
</code></pre></div></div>

<h1 id="testing--deploying-new-builds">Testing &amp; Deploying new builds</h1>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1) Pull code from git
2) Integrate to main branch
3) Build code (Jenkins)
4) Choose a deployment method (Jenkins)
	• OneAtATime
	• HalfAtATime
	• AllAtOnce
	• Custom
5) Deploy code according to the chosen method
	1) Stop running application
	2) Download application binary
	3) BeforeInstall: create backups
	4) Install (Ant/Maven for Java apps)
	5) Post-install config (log mgmt etc)
	6) AppStart
	7) Validate/Verify (monitor)
</code></pre></div></div>

<p><img src="/docs/assets/images/devops/devops-core/5.png" alt="Image" /></p>

<p><img src="/docs/assets/images/devops/devops-core/6.png" alt="Image" /></p>

<p><img src="/docs/assets/images/devops/devops-core/7.png" alt="Image" /></p>

<p><img src="/docs/assets/images/devops/devops-core/8.png" alt="Image" /></p>]]></content><author><name></name></author><category term="devops" /><summary type="html"><![CDATA[COMPONENTS OF DEVOPS • CI/CD • Continuous monitoring/improvement • IaC • Configuration management CONTINUOUS INTEGRATION / CONTINUOUS DEPLOYMENT • Continuous Integration (test DEV's code) ○ Automate code testing 1) Dev pushes code 2) Automated build 3) Automated unit/integration testing • Continuous deployment (deploy to PROD) 1) Dev pushes code 2) Automated build 3) Automated unit/integration testing 4) Additional manual tests 5) Provision resources § IaC scripts 6) Deploy • IaC scripts 7) Monitor 8) Rollback if necessary • Version control CONTINUOUS MONITORING/IMPROVEMENT METRICS/KPI • Change volume ○ Number of new lines of code ○ Number of bug fixes • Deployment frequency ○ How often a team is deploying ○ Should be consistent if mature software, upward trend if new • Time from starting dev to deployment • % of failed deployments ○ Review in conjunction with change volume! • Availability ○ How many releases led to =&gt; violations of SLA? ○ Average downtime? • Customer complaint volume • % change in user volume (sign-ups, log-ins) IaC • Template-driven deployment • Implement the following in an organization: ○ Standardization ○ Consistency ○ Compliance CONFIGURATION/CHANGE/PATCH/VULN MANAGEMENT • Chef/Puppet/Ansible (tools to manage IaC) ○ Automate sysadmin tasks including: ▫ Provisioning of resources ▫ Configuration &amp; management of IT resources • Increase productivity ○ Deploy to hundreds of resources simultaneously • Decrease downtime (IMMUTABLE DEPLOYMENT) (PATCH/VULN MGMT) 1) Update configuration on a subset of PROD machines 2) Test live against a subset of users 3) Gradually delete existing PROD machines and replace them with new machines with the new configuration 4) Monitor this process continuously TRADITIONAL ORGANIZATIONS • Disconnect between operations (administrators) and developers ○ They do not understand each other's needs ○ Might use different tools/processes § Devs might run their code on a certain OS build, whereas Ops might deploy on a different, incompatible OS build BENEFITS OF DEVOPS • Speed ○ Quick to new releases ○ Adapt to changing needs • Fast delivery ○ Automating end-to-end pipelines (dev, build, deployment) • Reliability ○ CI/CD for automated security testing • Scalability • Collaboration ○ Shared responsibility model between Dev &amp; Ops • Security ○ Automate security checking of the frequent changes INTRODUCING DEVSECOPS • Security automation &amp; at scale 1) Code: Scan all code for secret/access keys 2) Build: Tag security artifacts e.g. access tokens, encryption keys for easy ID 3) Test: Scan code for vulnerabilities, test security standards 4) Deploy: All security components should be in place. Checksums 5) Monitor: security standards, vulnerable dependencies, changing compliance regulations AppSec Testing • Software composition analysis (SCA) ○ Check for known vulns in dependencies (Snyk) • SAST ○ SonarQube, during coding (SonarLint) • DAST ○ Web app vuln scanner ○ Black-box pentest against live system • IAST ○ App is run by automated test; simultaneously run vulnerability tests IMPLEMENTING A CD STRATEGY • In-place deployment ○ Deploy in one big sweet ○ Full rollback only option to restore ○ Low cost, fast to deploy • Rolling deployment 1) Divide servers into groups 2) Deploy to 1 group at a time ○ Achieve zero down-time, easy rollback • Blue-green deployment ○ Blue env: PROD ○ Green env: new environment mimicking PROD ○ Gradually divert more and more of PROD traffic from blue to green (load balancing/canary analysis). 2 methods: 1) DNS cutover 2) Autoscaling • Replace existing servers with servers running new software version when autoscaling. ○ Zero downtime, easy rollback • Red-black deployment 1) Canary testing: divert 1% of prod traffic to new red environment 2) If all is OK, proceed. 3) Set resources for red environment based on current usage in PROD 4) DNS cutover from black (old PROD env) to new red env 5) Rollback: return DNS to black (old PROV env) 6) Use as Beta • Immutable deployment ○ Tear some servers down, spin up new ones, etc. ○ Good for older app infrastructures with many patches over time Continuous testing in CI/CD pipeline • Unit tests ○ 70% of testing ○ Conducted on programmer's PC ○ Detect bugs ○ Check: Code coverage, adherence to coding guidelines etc. • Integration/System testing ○ Testing environments that mimic PROD ○ Costlier ○ Different testing teams ○ Regression testing (code coverage) • User Acceptance Testing (UAT) ○ Replica of PROD ○ System/performance testing • A/B &amp; Canary testing ○ Final testing conducted in PROD ○ A/B &amp; Canary Testing § Divert % to new PROD systems § Ask users what they think § Collect feedback § Adjust new PROD system accordingly • Load testing of front-end, DB etc. Testing &amp; Deploying new builds 1) Pull code from git 2) Integrate to main branch 3) Build code (Jenkins) 4) Choose a deployment method (Jenkins) • OneAtATime • HalfAtATime • AllAtOnce • Custom 5) Deploy code according to the chosen method 1) Stop running application 2) Download application binary 3) BeforeInstall: create backups 4) Install (Ant/Maven for Java apps) 5) Post-install config (log mgmt etc) 6) AppStart 7) Validate/Verify (monitor)]]></summary></entry></feed>