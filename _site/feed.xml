<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.6">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2023-09-18T18:37:40+02:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">aljica</title><subtitle></subtitle><entry><title type="html">Using ChatGPT to Study for Certifications</title><link href="http://localhost:4000/chatgpt/2023/07/25/chatgpt-certifications.html" rel="alternate" type="text/html" title="Using ChatGPT to Study for Certifications" /><published>2023-07-25T00:00:00+02:00</published><updated>2023-07-25T00:00:00+02:00</updated><id>http://localhost:4000/chatgpt/2023/07/25/chatgpt-certifications</id><content type="html" xml:base="http://localhost:4000/chatgpt/2023/07/25/chatgpt-certifications.html"><![CDATA[<p>Here is a very simple but extremely powerful tool to study for certifications or just remembering valuable pieces of information.</p>

<p>Imagine you’re reading a section in a book chapter, a piece of online documentation, or anything else. Your normal process might be to take meticulous notes in your favourite text editor, summarizing it, maybe creating flash cards, your own practice questions, and so on.</p>

<p>Instead of doing that, try this:</p>

<p>Read your documentation, and only do that. Focus exclusively on understanding the information. Forget your notepad, forget everything else. It’s just your mind and the piece of information in front of you.</p>

<p>Once you’ve read the information once, or even twice, copy the section(s) you’re interested in and paste them into ChatGPT. Use the following prompt:</p>

<p>“Ask me as many questions as possible and allow me to answer them one by one, based on the following information: <em>paste here</em>”</p>

<p>You can even prompt it to ask you the questions with multiple-choices:</p>

<p>“Ask me as many multiple-choice questions as possible and allow me to answer them one by one, based on the following information: <em>paste here</em>”</p>

<p>The trick here is that you are pasting the information you want ChatGPT to quiz you on, as opposed to asking it to use its own knowledge. That way, you are guaranteed to get the correct information, and you are using ChatGPT as a practice exam / flash card generator.</p>

<p>Note that when you copy the information you’re reading, don’t worry if you’re on a website where there’s a bunch of videos and images and so on. Just copy the text you need and dump it in ChatGPT without worrying too much about formatting - ChatGPT is a powerful tool, so it understands. If you need information from just an image, there’s ways you can extract the text using OCR. If you are watching a Udemy video, click on “Transcripts” and everything the content creator said will appear in the right panel. Copy that and paste it into ChatGPT along with the prompt, and it will quiz you based on that.</p>

<p>To me, this is revolutionizing, because it allows me to fully immerse myself in watching the video or reading the paragraph, without worrying about switching tabs to take notes or subsequently creating flash cards and practice questions and reviewing my notes and so on - which is also very time consuming.</p>

<p>Instead, I can focus on one thing at a time, and afterwards, I have an extremely knowledgable teacher by my side who can both explain difficult concepts but also who will quiz me, which helps me with active recall for long-term retention. While ChatGPT asks me questions, I am actively practicing the Feynman Technique by both verbally explaining the answer to myself, and then I also have to formulate it properly in written form as a response to ChatGPT.</p>

<p>I hope this helps.</p>]]></content><author><name></name></author><category term="chatgpt" /><summary type="html"><![CDATA[Here is a very simple but extremely powerful tool to study for certifications or just remembering valuable pieces of information. Imagine you’re reading a section in a book chapter, a piece of online documentation, or anything else. Your normal process might be to take meticulous notes in your favourite text editor, summarizing it, maybe creating flash cards, your own practice questions, and so on. Instead of doing that, try this: Read your documentation, and only do that. Focus exclusively on understanding the information. Forget your notepad, forget everything else. It’s just your mind and the piece of information in front of you. Once you’ve read the information once, or even twice, copy the section(s) you’re interested in and paste them into ChatGPT. Use the following prompt: “Ask me as many questions as possible and allow me to answer them one by one, based on the following information: paste here” You can even prompt it to ask you the questions with multiple-choices: “Ask me as many multiple-choice questions as possible and allow me to answer them one by one, based on the following information: paste here” The trick here is that you are pasting the information you want ChatGPT to quiz you on, as opposed to asking it to use its own knowledge. That way, you are guaranteed to get the correct information, and you are using ChatGPT as a practice exam / flash card generator. Note that when you copy the information you’re reading, don’t worry if you’re on a website where there’s a bunch of videos and images and so on. Just copy the text you need and dump it in ChatGPT without worrying too much about formatting - ChatGPT is a powerful tool, so it understands. If you need information from just an image, there’s ways you can extract the text using OCR. If you are watching a Udemy video, click on “Transcripts” and everything the content creator said will appear in the right panel. Copy that and paste it into ChatGPT along with the prompt, and it will quiz you based on that. To me, this is revolutionizing, because it allows me to fully immerse myself in watching the video or reading the paragraph, without worrying about switching tabs to take notes or subsequently creating flash cards and practice questions and reviewing my notes and so on - which is also very time consuming. Instead, I can focus on one thing at a time, and afterwards, I have an extremely knowledgable teacher by my side who can both explain difficult concepts but also who will quiz me, which helps me with active recall for long-term retention. While ChatGPT asks me questions, I am actively practicing the Feynman Technique by both verbally explaining the answer to myself, and then I also have to formulate it properly in written form as a response to ChatGPT. I hope this helps.]]></summary></entry><entry><title type="html">MS Learn AZ-305 Pre-Requisites</title><link href="http://localhost:4000/azure/2023/07/01/architect-prerequisites.html" rel="alternate" type="text/html" title="MS Learn AZ-305 Pre-Requisites" /><published>2023-07-01T00:00:00+02:00</published><updated>2023-07-01T00:00:00+02:00</updated><id>http://localhost:4000/azure/2023/07/01/architect-prerequisites</id><content type="html" xml:base="http://localhost:4000/azure/2023/07/01/architect-prerequisites.html"><![CDATA[<p>Summary to be written.</p>]]></content><author><name></name></author><category term="azure" /><summary type="html"><![CDATA[Summary to be written.]]></summary></entry><entry><title type="html">Installing Kubernetes and Deploying a Flask App with NGINX</title><link href="http://localhost:4000/kubernetes/2023/06/21/kubernetes-setup.html" rel="alternate" type="text/html" title="Installing Kubernetes and Deploying a Flask App with NGINX" /><published>2023-06-21T00:00:00+02:00</published><updated>2023-06-21T00:00:00+02:00</updated><id>http://localhost:4000/kubernetes/2023/06/21/kubernetes-setup</id><content type="html" xml:base="http://localhost:4000/kubernetes/2023/06/21/kubernetes-setup.html"><![CDATA[<!--
![Image](/docs/assets/images/sysadmin-handbook/ch2/1.png)

![Image](/docs/assets/images/sysadmin-handbook/ch2/2.png)

![Image](/docs/assets/images/sysadmin-handbook/ch2/3.png)

![Image](/docs/assets/images/sysadmin-handbook/ch2/4.png)

![Image](/docs/assets/images/sysadmin-handbook/ch2/5.png)

<img src="/docs/assets/images/sysadmin-handbook/ch2/5.png" width="350" height="600">
-->

<h1 id="kubernetes-installation--configuration">Kubernetes Installation &amp; Configuration</h1>

<p>There are multiple articles that outline how to install Kubernetes, such as the following:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>https://levelup.gitconnected.com/a-step-by-step-guide-to-setup-kubernetes-cluster-in-virtualbox-ubuntu-20-04-image-91d4510bbf1c
https://www.keitaro.com/2021/09/03/setting-up-a-kubernetes-on-premise-cluster-with-kubeadm/
https://medium.com/nerd-for-tech/using-cri-o-as-container-runtime-for-kubernetes-b8ddf8326d38
https://adamtheautomator.com/cri-o/
</code></pre></div></div>

<p>In particular, we used the crio container runtime engine to power our Kubernetes cluster.</p>

<p><code class="highlighter-rouge">kubeadm init --pod-network-cidr=10.244.0.0/16 --cri-socket=unix:///var/run/crio.sock</code></p>

<p>Make sure you run <code class="highlighter-rouge">sudo swapoff -a</code> on the control plane, as swap must be turned off for it to work properly.</p>

<p>We created a very simple flask application, uploaded it to Docker Hub, used docker login on the control plane, pulled the image from Docker Hub with <code class="highlighter-rouge">docker pull</code>, then defined a .yaml file for deploying the flask application, followed by a .yaml file for the service to expose the application, and then set up an NGINX Ingress Controller in front of it.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx-ingress-controller
spec:
  replicas: 1
  selector:
    matchLabels:
      app: nginx-ingress
  template:
    metadata:
      labels:
        app: nginx-ingress
    spec:
      containers:
        - name: nginx-ingress-controller
          image: quay.io/kubernetes-ingress-controller/nginx-ingress-controller:0.34.1
          ports:
            - containerPort: 80

apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: flask-ingress
  annotations:
    nginx.ingress.kubernetes.io/rewrite-target: /
spec:
  rules:
    - http:
        paths:
          - path: /
            pathType: Prefix
            backend:
              service:
                name: flask-service
                port:
                  number: 5000
</code></pre></div></div>

<p>If you get this error:
<code class="highlighter-rouge">Unexpected error searching IngressClass: ingressclasses.networking.k8s.io "nginx" is forbidden: User "system:serviceaccount:default:default" cannot get resource "ingressclasses" in API group "networking.k8s.io" at the cluster scope</code></p>

<p>You should deploy the following on the K8s control plane:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: ingress-controller-role
rules:
- apiGroups: ["networking.k8s.io"]
  resources: ["ingressclasses"]
  verbs: ["get", "list"]

apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: ingress-controller-binding
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: ingress-controller-role
subjects:
- kind: ServiceAccount
  name: default # Replace with the actual service account used by the Ingress Controller
  namespace: default
</code></pre></div></div>

<p>Additionally, you may need to use Helm if you get the following error when deploying NGINX:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>"store.go:429 "Ignoring ingress because of error while validating ingress class" ingress="default/flask-ingress" error="ingress does not contain a valid IngressClass"

"store.go:429 "Ignoring ingress because of error while validating ingress class" ingress="default/flask-ingress" error="no object matching key \"nginx\" in local store"
</code></pre></div></div>

<p><code class="highlighter-rouge">helm install &lt;release_name&gt; ingress-nginx/ingress-nginx --set controller.ingressClass.name=&lt;desired_ingress_class_name&gt;</code></p>

<p>You may also need to delete validatingwebhookconfiguration as follows:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl get validatingwebhookconfiguration
kubectl delete validatingwebhookconfiguration &lt;name-of-resource-for-nginx-ingress-admission&gt;
https://stackoverflow.com/questions/68576225/failed-calling-webhook-validate-nginx-ingress-kubernetes-io-error-while-apply
</code></pre></div></div>

<p>If you’re running your cluster using VirtualBox, do the following to enable SSH:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1. VirtualBox -&gt; File -&gt; Tools -&gt; Network Manager -&gt; Host-only Networks tab
2. Set "Configure Adapter Automatically", and make sure DHCP Server is enabled.
3. Power off the VM.
4. VM -&gt; Settings -&gt; Network -&gt; Adapter 2 tab -&gt; Set it as Host-only Adapter
5. Boot up your VM again (once booted, make sure to disable swap again unless you've edited the configuration files that control it)
6. Run `sudo dhclient -1 enp0s8` (or whichever network interface is attached to the host-only adapter)
7. Now do `ip addr show`
8. You will see an IP assigned to the network interface (in this case enp0s8).
9. Connect to the control plane node from your local machine with `ssh username@ip`, using the IP you retrieved in the previous step.
10. You may also consider using the Remote_SSH VSCode Extension, if using VSCode.
</code></pre></div></div>]]></content><author><name></name></author><category term="kubernetes" /><summary type="html"><![CDATA[Kubernetes Installation &amp; Configuration There are multiple articles that outline how to install Kubernetes, such as the following: https://levelup.gitconnected.com/a-step-by-step-guide-to-setup-kubernetes-cluster-in-virtualbox-ubuntu-20-04-image-91d4510bbf1c https://www.keitaro.com/2021/09/03/setting-up-a-kubernetes-on-premise-cluster-with-kubeadm/ https://medium.com/nerd-for-tech/using-cri-o-as-container-runtime-for-kubernetes-b8ddf8326d38 https://adamtheautomator.com/cri-o/ In particular, we used the crio container runtime engine to power our Kubernetes cluster. kubeadm init --pod-network-cidr=10.244.0.0/16 --cri-socket=unix:///var/run/crio.sock Make sure you run sudo swapoff -a on the control plane, as swap must be turned off for it to work properly. We created a very simple flask application, uploaded it to Docker Hub, used docker login on the control plane, pulled the image from Docker Hub with docker pull, then defined a .yaml file for deploying the flask application, followed by a .yaml file for the service to expose the application, and then set up an NGINX Ingress Controller in front of it. apiVersion: apps/v1 kind: Deployment metadata: name: nginx-ingress-controller spec: replicas: 1 selector: matchLabels: app: nginx-ingress template: metadata: labels: app: nginx-ingress spec: containers: - name: nginx-ingress-controller image: quay.io/kubernetes-ingress-controller/nginx-ingress-controller:0.34.1 ports: - containerPort: 80 apiVersion: networking.k8s.io/v1 kind: Ingress metadata: name: flask-ingress annotations: nginx.ingress.kubernetes.io/rewrite-target: / spec: rules: - http: paths: - path: / pathType: Prefix backend: service: name: flask-service port: number: 5000 If you get this error: Unexpected error searching IngressClass: ingressclasses.networking.k8s.io "nginx" is forbidden: User "system:serviceaccount:default:default" cannot get resource "ingressclasses" in API group "networking.k8s.io" at the cluster scope You should deploy the following on the K8s control plane: apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRole metadata: name: ingress-controller-role rules: - apiGroups: ["networking.k8s.io"] resources: ["ingressclasses"] verbs: ["get", "list"] apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRoleBinding metadata: name: ingress-controller-binding roleRef: apiGroup: rbac.authorization.k8s.io kind: ClusterRole name: ingress-controller-role subjects: - kind: ServiceAccount name: default # Replace with the actual service account used by the Ingress Controller namespace: default Additionally, you may need to use Helm if you get the following error when deploying NGINX: "store.go:429 "Ignoring ingress because of error while validating ingress class" ingress="default/flask-ingress" error="ingress does not contain a valid IngressClass" "store.go:429 "Ignoring ingress because of error while validating ingress class" ingress="default/flask-ingress" error="no object matching key \"nginx\" in local store" helm install &lt;release_name&gt; ingress-nginx/ingress-nginx --set controller.ingressClass.name=&lt;desired_ingress_class_name&gt; You may also need to delete validatingwebhookconfiguration as follows: kubectl get validatingwebhookconfiguration kubectl delete validatingwebhookconfiguration &lt;name-of-resource-for-nginx-ingress-admission&gt; https://stackoverflow.com/questions/68576225/failed-calling-webhook-validate-nginx-ingress-kubernetes-io-error-while-apply If you’re running your cluster using VirtualBox, do the following to enable SSH: 1. VirtualBox -&gt; File -&gt; Tools -&gt; Network Manager -&gt; Host-only Networks tab 2. Set "Configure Adapter Automatically", and make sure DHCP Server is enabled. 3. Power off the VM. 4. VM -&gt; Settings -&gt; Network -&gt; Adapter 2 tab -&gt; Set it as Host-only Adapter 5. Boot up your VM again (once booted, make sure to disable swap again unless you've edited the configuration files that control it) 6. Run `sudo dhclient -1 enp0s8` (or whichever network interface is attached to the host-only adapter) 7. Now do `ip addr show` 8. You will see an IP assigned to the network interface (in this case enp0s8). 9. Connect to the control plane node from your local machine with `ssh username@ip`, using the IP you retrieved in the previous step. 10. You may also consider using the Remote_SSH VSCode Extension, if using VSCode.]]></summary></entry><entry><title type="html">Chapter 4 Process Control</title><link href="http://localhost:4000/sysadmin/2023/05/29/sysadmin-ch4.html" rel="alternate" type="text/html" title="Chapter 4 Process Control" /><published>2023-05-29T00:00:00+02:00</published><updated>2023-05-29T00:00:00+02:00</updated><id>http://localhost:4000/sysadmin/2023/05/29/sysadmin-ch4</id><content type="html" xml:base="http://localhost:4000/sysadmin/2023/05/29/sysadmin-ch4.html"><![CDATA[<h3 id="41-components-of-a-process">4.1 Components of a Process</h3>

<ul>
  <li>A process has a virtual address space, which maps into pages in physical memory.
    <ul>
      <li>A page is a sub-section of physical memory
        <ul>
          <li>Physical memory is equally divided into pages</li>
        </ul>
      </li>
      <li>These pages are randomly distributed in physical memory.</li>
      <li>A process consists of code, libraries, variables, stack, heap, etc.</li>
    </ul>
  </li>
  <li>Kernel internal data structures maintains:
    <ul>
      <li>A table that maps virtual address space to physical memory pages</li>
      <li>CPU, memory usage information</li>
      <li>Status</li>
      <li>Etc</li>
    </ul>
  </li>
  <li>All processes have one main thread</li>
  <li>They can have multiple threads, which can run simultaneously on multicore computer systems</li>
  <li>Threads of one process share the same memory</li>
</ul>

<h1 id="pid-process-id-number">PID: Process ID Number</h1>

<ul>
  <li>Each process gets an ID.</li>
  <li>Namespaces can further segregate/isolate processes from each other.
    <ul>
      <li>With namespaces, a process can have different PIDs depending on which other process is checking for it.</li>
    </ul>
  </li>
</ul>

<h1 id="ppid-parent-pid">PPID: Parent PID</h1>

<ul>
  <li>Parent &amp; Child processes.</li>
  <li>If the parent dies, init/systemd becomes the new parent.</li>
  <li>Misbehaving applications can be traced back to their parents; this can be helpful.</li>
</ul>

<h1 id="uid-and-euid-realeffective-user-id">UID and EUID: real/effective user ID</h1>

<ul>
  <li>Process has UID value; this is the UID of the user who created the parent process.</li>
  <li>Effective UID: the files/programs a process has access to.</li>
  <li>UID/EUID different only for SETUID programs.</li>
  <li>Saved UID: A SETUID program can place its root privileges here for most of execution, and only change the EUID for the SID for when it needs root.</li>
</ul>

<h1 id="gid-and-egid-real-and-effective-group-id">GID and EGID: real and effective group ID</h1>

<ul>
  <li>Same concept as for UID and EUID, but for groups.</li>
  <li>GID is really only relevant when a process creates new files; depending on file system permission settings, new files might set the GID of its creator as owner.</li>
</ul>

<h1 id="niceness">Niceness</h1>

<ul>
  <li>A process gets scheduled based on 2 main factors, derived from an algorithm:
    <ol>
      <li>How much CPU time it has used, and</li>
      <li>how long it has waited to execute.</li>
    </ol>
  </li>
</ul>

<h1 id="control-terminal">Control terminal</h1>

<ul>
  <li>For nondaemon processes, a control terminal determines that process’s STDIN/STDOUT/STDERR channels, sends the process keyboard events (CTRL+C) etc.</li>
  <li>When you use your terminal to run a command/process, your terminal acts as a control terminal.</li>
</ul>

<h3 id="42-the-lifecycle-of-a-process">4.2 The Lifecycle of a Process</h3>

<ul>
  <li>fork() system call copies a parent process’s memory, code, variables, stack, heap, etc, into a child process.
    <ul>
      <li>clone() is actually used behind the scenes of fork() - clone() includes threads and additional features.</li>
    </ul>
  </li>
  <li>fork() returns 2 different values - the child process gets the value 0, the parent gets the PID of the newly created child.
    <ul>
      <li>This way, in the code, you can have an if statement that checks if(fork() == 0) - then you know you are executing inside the child process.</li>
      <li>If fork() equals PID of the child, then you are executing in the parent process.</li>
    </ul>
  </li>
  <li>The child can use an exec() command to run another command.
    <ul>
      <li>Exec() also resets various memory segments so that the newly executing command becomes its own process entirely; the fork() command helps it setup the core things needed for a process - e.g. code, variables, stack, heap, etc. by simply copying them from the parent - but then it can change those and run as an entirely independent process.</li>
    </ul>
  </li>
  <li>Upon system startup, kernel creates the init / systemd process.
    <ul>
      <li>All subsequent processes are children of init / systemd with PID 1.</li>
    </ul>
  </li>
  <li>A completed process calls _exit routine to notify kernel it’s ready to die.
    <ul>
      <li>Process sends exit code.</li>
    </ul>
  </li>
  <li>Parent uses wait() to acknowledge death of child.
    <ul>
      <li>Parent can examine exit code &amp; other stats.</li>
      <li>If parent dies first, orphans are adopted by init / systemd which handles wait() and removal of children.</li>
    </ul>
  </li>
</ul>

<h1 id="signals">Signals</h1>

<ul>
  <li>Can be sent among processes as a means of communication</li>
  <li>CTRL+C / CTRL+Z</li>
  <li>kill command used by administrator</li>
  <li>Used by kernel to:
    <ul>
      <li>Notify a process of e.g. death of child</li>
      <li>Kill processes that commit infractions (e.g. division by zero).</li>
      <li>Much more.</li>
    </ul>
  </li>
  <li>A process can have a signal handler function that gets called when a particular signal is received.</li>
  <li>Otherwise, kernel handles it.</li>
  <li>Results can be:
    <ul>
      <li>Termination of process.</li>
      <li>Core dump (memory image of process is logged) - debugging.</li>
    </ul>
  </li>
  <li>Processes can block / ignore signals.
    <ul>
      <li>Blocked:
        <ul>
          <li>Process must explicitly unblock the signal; it is queued by the kernel.
            <ul>
              <li>Handler function called only once, even if multiple signals in queue.</li>
            </ul>
          </li>
          <li>Ignored: signals are dropped.</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p><img src="/docs/assets/images/sysadmin-handbook/ch4/signals.jpeg" alt="Image" /></p>

<ul>
  <li>KILL and STOP cannot be caught/blocked/ignored.</li>
  <li>STOP suspends process execution until CONT is received.
    <ul>
      <li>CONT may be ignored/caught, but not blocked.</li>
    </ul>
  </li>
  <li>CTRL+Z =&gt; soft “STOP” =&gt; “request to stop”.
    <ul>
      <li>Programs must not have a handler function for this - i.e. they can ignore it.</li>
    </ul>
  </li>
  <li>Differentiation between different signals:
    <ul>
      <li>KILL -
        <ul>
          <li>Unblockable.</li>
          <li>Terminates process.</li>
        </ul>
      </li>
      <li>INT -
        <ul>
          <li>CTRL+C</li>
          <li>Request to terminate current operation.
            <ul>
              <li>Process may catch &amp; react to signal.</li>
              <li>Default behavior if not handler routine is for process to be killed.</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>]]></content><author><name></name></author><category term="sysadmin" /><summary type="html"><![CDATA[4.1 Components of a Process A process has a virtual address space, which maps into pages in physical memory. A page is a sub-section of physical memory Physical memory is equally divided into pages These pages are randomly distributed in physical memory. A process consists of code, libraries, variables, stack, heap, etc. Kernel internal data structures maintains: A table that maps virtual address space to physical memory pages CPU, memory usage information Status Etc All processes have one main thread They can have multiple threads, which can run simultaneously on multicore computer systems Threads of one process share the same memory PID: Process ID Number Each process gets an ID. Namespaces can further segregate/isolate processes from each other. With namespaces, a process can have different PIDs depending on which other process is checking for it. PPID: Parent PID Parent &amp; Child processes. If the parent dies, init/systemd becomes the new parent. Misbehaving applications can be traced back to their parents; this can be helpful. UID and EUID: real/effective user ID Process has UID value; this is the UID of the user who created the parent process. Effective UID: the files/programs a process has access to. UID/EUID different only for SETUID programs. Saved UID: A SETUID program can place its root privileges here for most of execution, and only change the EUID for the SID for when it needs root. GID and EGID: real and effective group ID Same concept as for UID and EUID, but for groups. GID is really only relevant when a process creates new files; depending on file system permission settings, new files might set the GID of its creator as owner. Niceness A process gets scheduled based on 2 main factors, derived from an algorithm: How much CPU time it has used, and how long it has waited to execute. Control terminal For nondaemon processes, a control terminal determines that process’s STDIN/STDOUT/STDERR channels, sends the process keyboard events (CTRL+C) etc. When you use your terminal to run a command/process, your terminal acts as a control terminal. 4.2 The Lifecycle of a Process fork() system call copies a parent process’s memory, code, variables, stack, heap, etc, into a child process. clone() is actually used behind the scenes of fork() - clone() includes threads and additional features. fork() returns 2 different values - the child process gets the value 0, the parent gets the PID of the newly created child. This way, in the code, you can have an if statement that checks if(fork() == 0) - then you know you are executing inside the child process. If fork() equals PID of the child, then you are executing in the parent process. The child can use an exec() command to run another command. Exec() also resets various memory segments so that the newly executing command becomes its own process entirely; the fork() command helps it setup the core things needed for a process - e.g. code, variables, stack, heap, etc. by simply copying them from the parent - but then it can change those and run as an entirely independent process. Upon system startup, kernel creates the init / systemd process. All subsequent processes are children of init / systemd with PID 1. A completed process calls _exit routine to notify kernel it’s ready to die. Process sends exit code. Parent uses wait() to acknowledge death of child. Parent can examine exit code &amp; other stats. If parent dies first, orphans are adopted by init / systemd which handles wait() and removal of children. Signals Can be sent among processes as a means of communication CTRL+C / CTRL+Z kill command used by administrator Used by kernel to: Notify a process of e.g. death of child Kill processes that commit infractions (e.g. division by zero). Much more. A process can have a signal handler function that gets called when a particular signal is received. Otherwise, kernel handles it. Results can be: Termination of process. Core dump (memory image of process is logged) - debugging. Processes can block / ignore signals. Blocked: Process must explicitly unblock the signal; it is queued by the kernel. Handler function called only once, even if multiple signals in queue. Ignored: signals are dropped. KILL and STOP cannot be caught/blocked/ignored. STOP suspends process execution until CONT is received. CONT may be ignored/caught, but not blocked. CTRL+Z =&gt; soft “STOP” =&gt; “request to stop”. Programs must not have a handler function for this - i.e. they can ignore it. Differentiation between different signals: KILL - Unblockable. Terminates process. INT - CTRL+C Request to terminate current operation. Process may catch &amp; react to signal. Default behavior if not handler routine is for process to be killed.]]></summary></entry><entry><title type="html">The Linux Programming Interface Chapter 29 Threads</title><link href="http://localhost:4000/tlpi/2023/05/29/tlpi-ch29.html" rel="alternate" type="text/html" title="The Linux Programming Interface Chapter 29 Threads" /><published>2023-05-29T00:00:00+02:00</published><updated>2023-05-29T00:00:00+02:00</updated><id>http://localhost:4000/tlpi/2023/05/29/tlpi-ch29</id><content type="html" xml:base="http://localhost:4000/tlpi/2023/05/29/tlpi-ch29.html"><![CDATA[<h3 id="29-threads-introduction">29 Threads: Introduction</h3>

<ul>
  <li>How POSIX Threads (PThreads) work</li>
  <li>When to use multithreaded vs multiprocess applications?</li>
</ul>

<h3 id="291-overview">29.1 Overview</h3>

<ul>
  <li>A regular process is a single-threaded process.</li>
  <li>Threads share the same memory; (un)initialized data, heap, code, but have different stacks.</li>
  <li>On multi-core systems, threads can execute concurrently (e.g. while one waits for I/O).</li>
</ul>

<p><img src="/docs/assets/images/tlpi/ch29/threads1.jpg" alt="Image" /></p>

<ul>
  <li>Achieving concurrency in concurrent applications, e.g. network servers:
    <ul>
      <li>Possible to use fork() i.e. multiprocess, or multithreaded.</li>
      <li>Disadvantages of multiprocess [using fork()]:
        <ol>
          <li>Expensive (copying page tables, file attributes, and much more).</li>
          <li>Cannot easily exchange information between parent and child processes.</li>
        </ol>
      </li>
      <li>Threads address these problems:
        <ol>
          <li>Faster than copying with fork().</li>
          <li>All threads share the same data.</li>
        </ol>
      </li>
    </ul>
  </li>
  <li>Threads share a number of attributes:
    <ul>
      <li>PID and parent PID.</li>
      <li>Process GID and Session ID.</li>
      <li>Controlling terminal.</li>
      <li>Process credentials (UID/GID).</li>
      <li>Open file descriptors.</li>
      <li>Record locks.</li>
      <li>Signal dispositions.</li>
      <li>Current working dir, root dir, etc.</li>
      <li>Interval timers.</li>
      <li>System V semaphore.</li>
      <li>Resource limits.</li>
      <li>CPU time consumed.</li>
      <li>Resources consumed.</li>
      <li>Nice value (setpriority(), scheduling).</li>
    </ul>
  </li>
  <li>Threads have different values for:
    <ul>
      <li>Thread ID.</li>
      <li>Signal mask.</li>
      <li>Thread-specific data.</li>
      <li>Alternate signal stack.</li>
      <li>Errno variable.</li>
      <li>Floating-point environment.</li>
      <li>Realtime scheduling policy/priority.</li>
      <li>CPU affinity.</li>
      <li>Capabilities.</li>
      <li>Stack.</li>
    </ul>
  </li>
  <li>Threads CAN share stacks, but be very careful.
    <ul>
      <li>If one thread returns and another thread has a pointer to something on that threads stack, that stack frame may get popped.
        <ul>
          <li>This can lead to very obscure bugs.</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3 id="292-background-details-of-the-pthreads-api">29.2 Background details of the Pthreads API</h3>

<h1 id="pthreads-data-types">Pthreads data types</h1>

<p><img src="/docs/assets/images/tlpi/ch29/threads-data-types.jpeg" alt="Image" /></p>

<h1 id="threads-and-errno">Threads and errno</h1>

<ul>
  <li>Global errno does not work with multithreaded applications; otherwise, how would a given thread know when an error code is meant for itself?</li>
  <li>Thus, multithreaded programs have their own errcode for each thread.</li>
</ul>

<h1 id="return-value-from-pthreads-functions">Return value from Pthreads functions</h1>

<ul>
  <li>0 on success, positive value on failure.
    <ul>
      <li>Usually on Linux it’s 0 on success, negative value on failure.</li>
    </ul>
  </li>
  <li>Each errno reference means a function call.
    <ul>
      <li>Thus, store the result of a pthread_create() call in another local variable to avoid this overhead.</li>
    </ul>
  </li>
</ul>

<pre><code class="language-C">int s;
s = pthread_create(&amp;thread, NULL, func, &amp;arg);
if (s != 0)
    errExit("pthread_create failed");
</code></pre>

<h1 id="compiling-pthreads-programs">Compiling pthreads programs</h1>

<ul>
  <li>Use the <code class="highlighter-rouge">cc - pthread</code> option when compiling.
    <ul>
      <li>Preprocessor defines the _REENTRANT macro.
        <ul>
          <li>Re-entrant function definition:
            <ul>
              <li>A program can be interrupted in the middle of its execution, and then resumed.</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3 id="293-thread-creation">29.3 Thread Creation</h3>

<pre><code class="language-C">#include &lt;pthread.h&gt;

int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start)(void *), void *arg);
</code></pre>

<ul>
  <li>The existing thread calls pthread_create, which creates a new thread and calls the function “start” with the “arg” as argument (start(arg)).
    <ul>
      <li>The existing thread then continues execution from the next line of code.</li>
    </ul>
  </li>
  <li>We can pass a pointer as arg.
    <ul>
      <li>Pass pointer to a struct if you require multiple arguments.</li>
      <li>It can also be NULL.</li>
    </ul>
  </li>
  <li>
    <p>Return value of start is void - its usage will be further explained.</p>
  </li>
  <li>
    <p>Thread points to a buffer of type pthread_t.</p>
  </li>
  <li>After a call to pthread_create, threads may run simultaneously.</li>
  <li>Scheduling policies may mean that threads execute concurrently on different cores.</li>
</ul>

<h3 id="296-joining-with-a-terminated-thread">29.6 Joining with a terminated thread</h3>

<ul>
  <li>pthread_join() waits for thread to terminate.
    <ul>
      <li>If that thread already terminated, pthread_join() returns immediately.</li>
    </ul>
  </li>
</ul>

<p><code class="highlighter-rouge">int pthread_join(pthread_t thread, void **retval);</code></p>

<h3 id="simple-thread">Simple thread</h3>

<pre><code class="language-C">#include &lt;pthread.h&gt;
#include "tlpi_hdr.h"

static void *
threadFunc(void *arg)
{
    char *s = (char *) arg;

    printf("%s", s);

    return (void *) strlen(s);
}

int
main(int argc, char *argv[])
{
    pthread_t t1;
    void *res;
    int s;

    s = pthread_create(&amp;t1, NULL, threadFunc, "Hello world\n");
    if (s != 0)
        errExitEN(s, "pthread_create");

    printf("Message from main()\n");
    s = pthread_join(t1, &amp;res);
    if (s != 0)
        errExitEN(s, "pthread_join");

    printf("Thread returned %ld\n", (long) res);

    exit(EXIT_SUCCESS);
}
</code></pre>]]></content><author><name></name></author><category term="tlpi" /><summary type="html"><![CDATA[29 Threads: Introduction How POSIX Threads (PThreads) work When to use multithreaded vs multiprocess applications? 29.1 Overview A regular process is a single-threaded process. Threads share the same memory; (un)initialized data, heap, code, but have different stacks. On multi-core systems, threads can execute concurrently (e.g. while one waits for I/O). Achieving concurrency in concurrent applications, e.g. network servers: Possible to use fork() i.e. multiprocess, or multithreaded. Disadvantages of multiprocess [using fork()]: Expensive (copying page tables, file attributes, and much more). Cannot easily exchange information between parent and child processes. Threads address these problems: Faster than copying with fork(). All threads share the same data. Threads share a number of attributes: PID and parent PID. Process GID and Session ID. Controlling terminal. Process credentials (UID/GID). Open file descriptors. Record locks. Signal dispositions. Current working dir, root dir, etc. Interval timers. System V semaphore. Resource limits. CPU time consumed. Resources consumed. Nice value (setpriority(), scheduling). Threads have different values for: Thread ID. Signal mask. Thread-specific data. Alternate signal stack. Errno variable. Floating-point environment. Realtime scheduling policy/priority. CPU affinity. Capabilities. Stack. Threads CAN share stacks, but be very careful. If one thread returns and another thread has a pointer to something on that threads stack, that stack frame may get popped. This can lead to very obscure bugs. 29.2 Background details of the Pthreads API Pthreads data types Threads and errno Global errno does not work with multithreaded applications; otherwise, how would a given thread know when an error code is meant for itself? Thus, multithreaded programs have their own errcode for each thread. Return value from Pthreads functions 0 on success, positive value on failure. Usually on Linux it’s 0 on success, negative value on failure. Each errno reference means a function call. Thus, store the result of a pthread_create() call in another local variable to avoid this overhead. int s; s = pthread_create(&amp;thread, NULL, func, &amp;arg); if (s != 0) errExit("pthread_create failed"); Compiling pthreads programs Use the cc - pthread option when compiling. Preprocessor defines the _REENTRANT macro. Re-entrant function definition: A program can be interrupted in the middle of its execution, and then resumed. 29.3 Thread Creation #include &lt;pthread.h&gt; int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start)(void *), void *arg); The existing thread calls pthread_create, which creates a new thread and calls the function “start” with the “arg” as argument (start(arg)). The existing thread then continues execution from the next line of code. We can pass a pointer as arg. Pass pointer to a struct if you require multiple arguments. It can also be NULL. Return value of start is void - its usage will be further explained. Thread points to a buffer of type pthread_t. After a call to pthread_create, threads may run simultaneously. Scheduling policies may mean that threads execute concurrently on different cores. 29.6 Joining with a terminated thread pthread_join() waits for thread to terminate. If that thread already terminated, pthread_join() returns immediately. int pthread_join(pthread_t thread, void **retval); Simple thread #include &lt;pthread.h&gt; #include "tlpi_hdr.h" static void * threadFunc(void *arg) { char *s = (char *) arg; printf("%s", s); return (void *) strlen(s); } int main(int argc, char *argv[]) { pthread_t t1; void *res; int s; s = pthread_create(&amp;t1, NULL, threadFunc, "Hello world\n"); if (s != 0) errExitEN(s, "pthread_create"); printf("Message from main()\n"); s = pthread_join(t1, &amp;res); if (s != 0) errExitEN(s, "pthread_join"); printf("Thread returned %ld\n", (long) res); exit(EXIT_SUCCESS); }]]></summary></entry><entry><title type="html">Chapter 6 Cryptography and Symmetric Key Algorithms</title><link href="http://localhost:4000/cissp/2023/05/23/cissp-ch6.html" rel="alternate" type="text/html" title="Chapter 6 Cryptography and Symmetric Key Algorithms" /><published>2023-05-23T00:00:00+02:00</published><updated>2023-05-23T00:00:00+02:00</updated><id>http://localhost:4000/cissp/2023/05/23/cissp-ch6</id><content type="html" xml:base="http://localhost:4000/cissp/2023/05/23/cissp-ch6.html"><![CDATA[<ul>
  <li>Cryptographic provides CIA for:
    <ul>
      <li>Data at rest.</li>
      <li>Data in transit.</li>
      <li>Data in use (in memory).</li>
    </ul>
  </li>
  <li>Historical “arms race” of researchers developing stronger encryption algorithms, while hackers tried to break them.
    <ul>
      <li>We now have very sophisticated algorithms.</li>
    </ul>
  </li>
</ul>

<h3 id="cryptographic-foundations">Cryptographic Foundations</h3>

<h1 id="goals-of-cryptography">Goals of Cryptography</h1>

<ul>
  <li>4 fundamentals goals:
    <ul>
      <li>Confidentiality</li>
      <li>Integrity</li>
      <li>Authentication</li>
      <li>Nonrepudiation</li>
    </ul>
  </li>
  <li>Not all cryptosystems are designed to reach each goal.</li>
</ul>

<h4 id="confidentiality">Confidentiality</h4>

<ul>
  <li>Data remains private in rest, in transit, in use.</li>
  <li>“The preservation of secrecy”.</li>
  <li>Symmetric cryptosystems
    <ul>
      <li>Shared key among users</li>
    </ul>
  </li>
  <li>Asymmetric cryptosystems
    <ul>
      <li>Unique public/private keypair for each user</li>
    </ul>
  </li>
  <li>Data at rest
    <ul>
      <li>On hard drives, backup tapes, USB, etc.</li>
      <li>Data leak through physical theft of device</li>
    </ul>
  </li>
  <li>Data in motion (“data on the wire”)
    <ul>
      <li>Transmissions over network mediums</li>
      <li>Data leak through eavesdropping attacks</li>
    </ul>
  </li>
  <li>Data in use
    <ul>
      <li>Active in computer memory</li>
      <li>Data leak through improper process isolation at operating system-layer</li>
    </ul>
  </li>
</ul>

<h4 id="integrity">Integrity</h4>

<ul>
  <li>Ensures that data is not altered without authorization.</li>
  <li>Encrypted message digests.
    <ul>
      <li>Digital signatures (created using cryptography) to verify the contents of a message.</li>
      <li>A recipient can then re-compute the signature for a message and compare it with the previous one to see if the message has been tampered with.</li>
    </ul>
  </li>
  <li>Ensures data was not altered between time of creation and time of access.</li>
  <li>Allows for file integrity checking.</li>
</ul>

<h4 id="authentication">Authentication</h4>

<ul>
  <li>Verify a claimed identity.</li>
  <li>Challenge-Response authentication protocol:
    <ul>
      <li>Alice and Bob have a shared secret key and wish to communicate.</li>
      <li>When they begin communicating online and claim who they are, Alice can ask Bob to encrypt a short message with the secret key they both know.</li>
      <li>If Bob can return such an encrypted message, Alice can be certain it’s him, because only they know that secret key.</li>
    </ul>
  </li>
</ul>

<p><img src="/docs/assets/images/cissp/ch6/alice-bob-auth.png" alt="Image" /></p>

<h4 id="nonrepudiation">Nonrepudiation</h4>

<ul>
  <li>Ensures who sent a message, and the fact that they did send that message.</li>
  <li>If only Bob knows the secret key, it must have been him who sent the message.
    <ul>
      <li>He can’t later claim he didn’t.</li>
      <li>Unless the key was somehow leaked of course!</li>
    </ul>
  </li>
  <li>This property is provided by ASYMMETRIC cryptosystems.</li>
</ul>

<h1 id="cryptography-concepts">Cryptography Concepts</h1>

<ul>
  <li>Plaintext (denoted “P”)
    <ul>
      <li>Regular message before encryption</li>
    </ul>
  </li>
  <li>Sender uses an algorithm used to <em>encrypt</em> <em>plaintext</em>
    <ul>
      <li>This produces a <em>ciphertext</em> (C)</li>
    </ul>
  </li>
  <li>
    <p>Recipient uses an algorithm (not necessarily different from the one sender used) to <em>decrypt</em> the C into P.</p>
  </li>
  <li>Cryptographic algorithms rely on <em>keys</em>
    <ul>
      <li>Key = usually just a number</li>
    </ul>
  </li>
  <li>Each algorithm has its own <em>key space</em>
    <ul>
      <li>Key space = Valid range of values for a key</li>
      <li>Defined by its <em>bit size</em>
        <ul>
          <li>Number of binary digits (1s and 0s) in the key</li>
        </ul>
      </li>
      <li>If bit size is 5, then key space is the range of numbers:
        <ul>
          <li>00000 (in binary) = 0 (in decimal)</li>
          <li>11111 = 31 (i.e. 2<sup>5</sup>)</li>
        </ul>
      </li>
      <li>128-bit key has key space from 0 to 2<sup>128</sup></li>
      <li>n-bit key has key space from 0 to 2<sup>n</sup></li>
    </ul>
  </li>
  <li>
    <p>Keep your keys SECRET!</p>
  </li>
  <li>Kerchkoff’s Principle
    <ul>
      <li>Algorithms used for encryption &amp; decryption should be public</li>
      <li>Cryptographic system should be secure even if everything except the secret key is known!
        <ul>
          <li>Security through obscurity is not better.
            <ul>
              <li>Public exposure =&gt; researchers can find weaknessess/faults quicker!</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li><em>“Cryptovariables”</em> - name for cryptographic keys</li>
  <li><em>“Cryptography”</em> - Creating/implementing secret codes/ciphers</li>
  <li><em>“Cryptanalysis”</em> - the study of methods to defeat ciphers</li>
  <li><em>“Cryptology”</em> - Cryptography &amp; Cryptanalysis combined</li>
  <li><em>“Cryptosystems”</em> - Specific implementations of a cipher in hardware/software</li>
  <li>Federal Information Processing Standard (FIPS) 140-2 “Security Requirements for Cryptographic Modules”
    <ul>
      <li>Document outlining the hardware/software requirements for federal government in the U.S.</li>
    </ul>
  </li>
</ul>

<h1 id="cryptographic-mathematics">Cryptographic Mathematics</h1>

<ul>
  <li>We will here discuss mathematics; logical operations that are the foundations of cryptography.</li>
  <li>You will not need to do math or solve cryptographical problems in a mathematical sense; but it’s vital for your understanding!</li>
</ul>

<h4 id="boolean-mathematics">Boolean Mathematics</h4>

<ul>
  <li>Decimal system - base 10 system
    <ul>
      <li>Each place value in a number is a multiple of 10</li>
      <li>E.g. the number “21” can be calculated (going from right to left):
        <ul>
          <li>1 * 10<sup>0</sup> + 2 * 10<sup>1</sup> = 1 * 1 + 2 * 10 = 1 + 20 = 21</li>
        </ul>
      </li>
      <li>In binary, “1011 is calculated as (going from right to left):
        <ul>
          <li>1 * 2<sup>0</sup> + 1 * 2<sup>1</sup> + 0 * 2<sup>2</sup> + 1 * 2<sup>3</sup> = 1 + 2 + 0 + 8 = 11</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h4 id="logical-operations">Logical operations</h4>

<ul>
  <li>Manipulating data:</li>
</ul>

<h4 id="and-operation">AND operation</h4>

<ul>
  <li>Symbol ^
    <ul>
      <li>E.g. 1011 ^ 1111</li>
      <li>The AND operation takes TWO inputs at a time.</li>
      <li>So from 1011, we take the 1 from the left, and from 1111, we take the 1 from the left, and we input them to the AND function
        <ul>
          <li>The AND operation returns 1 if both input bits are 1, and returns 0 otherwise:</li>
          <li>Since both are 1’s, the first output/return value in the resulting number is also 1</li>
        </ul>
      </li>
      <li>See the examples below.</li>
    </ul>
  </li>
</ul>

<p><img src="/docs/assets/images/cissp/ch6/x-y-boolean.jpeg" alt="Image" /></p>

<p><img src="/docs/assets/images/cissp/ch6/full-and.jpeg" alt="Image" /></p>

<h4 id="or">OR</h4>

<ul>
  <li>The symbol for OR is V.</li>
  <li>If X and Y are both 0, the output is 0.
    <ul>
      <li>Else, the output is 1.</li>
    </ul>
  </li>
  <li>Can you figure out the output of X: 0 1 1 0 1 1 0 0 OR Y: 1 0 1 0 0 1 1 1?</li>
</ul>
<details>
    <summary>Answer</summary>

    X V Y: 1 1 1 0 1 1 1 1

</details>

<h4 id="not">NOT</h4>

<ul>
  <li>Symbol for NOT is ~</li>
  <li>Invert a bit</li>
  <li>If X is 1, ~X would be 0, and vice versa.</li>
</ul>

<h4 id="exclusive-or-xor">Exclusive OR (XOR)</h4>

<ul>
  <li>Symbol is ⊕</li>
  <li>If X and Y are both 0’s or 1’s, the output is 0.
    <ul>
      <li>Else, if X and Y are both different (e.g. X is 0 and Y is 1, or X is 1 and Y is 0), the output is 1.</li>
    </ul>
  </li>
  <li>Can you solve 0 1 1 0 1 1 0 0 ⊕ 1 0 1 0 0 1 1 1</li>
</ul>

<details>
    <summary>Answer</summary>

    X &oplus; Y: 1 1 0 0 1 0 1 1

</details>

<h4 id="modulo-function">Modulo function</h4>

<ul>
  <li>Symbol can be either the word “mod” or the percentage %</li>
  <li>Modulo returns the remainder of a division operation
    <ul>
      <li>Let’s say you divide 6 by 4, i.e. 6 / 4</li>
      <li>The result is 1 (because 4 fits only once into 6) with a remainder value of 2</li>
      <li>The module function outputs that remainder value 2
        <ul>
          <li>So: 6 mod 4 = 6 % 4 = 2</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Can you figure out what 33 mod 10 is?</li>
</ul>
<details>
    <summary>Answer</summary>

    33 mod 10 = 33 % 10 = 3

</details>

<h4 id="one-way-functions">One-Way Functions</h4>]]></content><author><name></name></author><category term="cissp" /><summary type="html"><![CDATA[Cryptographic provides CIA for: Data at rest. Data in transit. Data in use (in memory). Historical “arms race” of researchers developing stronger encryption algorithms, while hackers tried to break them. We now have very sophisticated algorithms. Cryptographic Foundations Goals of Cryptography 4 fundamentals goals: Confidentiality Integrity Authentication Nonrepudiation Not all cryptosystems are designed to reach each goal. Confidentiality Data remains private in rest, in transit, in use. “The preservation of secrecy”. Symmetric cryptosystems Shared key among users Asymmetric cryptosystems Unique public/private keypair for each user Data at rest On hard drives, backup tapes, USB, etc. Data leak through physical theft of device Data in motion (“data on the wire”) Transmissions over network mediums Data leak through eavesdropping attacks Data in use Active in computer memory Data leak through improper process isolation at operating system-layer Integrity Ensures that data is not altered without authorization. Encrypted message digests. Digital signatures (created using cryptography) to verify the contents of a message. A recipient can then re-compute the signature for a message and compare it with the previous one to see if the message has been tampered with. Ensures data was not altered between time of creation and time of access. Allows for file integrity checking. Authentication Verify a claimed identity. Challenge-Response authentication protocol: Alice and Bob have a shared secret key and wish to communicate. When they begin communicating online and claim who they are, Alice can ask Bob to encrypt a short message with the secret key they both know. If Bob can return such an encrypted message, Alice can be certain it’s him, because only they know that secret key. Nonrepudiation Ensures who sent a message, and the fact that they did send that message. If only Bob knows the secret key, it must have been him who sent the message. He can’t later claim he didn’t. Unless the key was somehow leaked of course! This property is provided by ASYMMETRIC cryptosystems. Cryptography Concepts Plaintext (denoted “P”) Regular message before encryption Sender uses an algorithm used to encrypt plaintext This produces a ciphertext (C) Recipient uses an algorithm (not necessarily different from the one sender used) to decrypt the C into P. Cryptographic algorithms rely on keys Key = usually just a number Each algorithm has its own key space Key space = Valid range of values for a key Defined by its bit size Number of binary digits (1s and 0s) in the key If bit size is 5, then key space is the range of numbers: 00000 (in binary) = 0 (in decimal) 11111 = 31 (i.e. 25) 128-bit key has key space from 0 to 2128 n-bit key has key space from 0 to 2n Keep your keys SECRET! Kerchkoff’s Principle Algorithms used for encryption &amp; decryption should be public Cryptographic system should be secure even if everything except the secret key is known! Security through obscurity is not better. Public exposure =&gt; researchers can find weaknessess/faults quicker! “Cryptovariables” - name for cryptographic keys “Cryptography” - Creating/implementing secret codes/ciphers “Cryptanalysis” - the study of methods to defeat ciphers “Cryptology” - Cryptography &amp; Cryptanalysis combined “Cryptosystems” - Specific implementations of a cipher in hardware/software Federal Information Processing Standard (FIPS) 140-2 “Security Requirements for Cryptographic Modules” Document outlining the hardware/software requirements for federal government in the U.S. Cryptographic Mathematics We will here discuss mathematics; logical operations that are the foundations of cryptography. You will not need to do math or solve cryptographical problems in a mathematical sense; but it’s vital for your understanding! Boolean Mathematics Decimal system - base 10 system Each place value in a number is a multiple of 10 E.g. the number “21” can be calculated (going from right to left): 1 * 100 + 2 * 101 = 1 * 1 + 2 * 10 = 1 + 20 = 21 In binary, “1011 is calculated as (going from right to left): 1 * 20 + 1 * 21 + 0 * 22 + 1 * 23 = 1 + 2 + 0 + 8 = 11 Logical operations Manipulating data: AND operation Symbol ^ E.g. 1011 ^ 1111 The AND operation takes TWO inputs at a time. So from 1011, we take the 1 from the left, and from 1111, we take the 1 from the left, and we input them to the AND function The AND operation returns 1 if both input bits are 1, and returns 0 otherwise: Since both are 1’s, the first output/return value in the resulting number is also 1 See the examples below. OR The symbol for OR is V. If X and Y are both 0, the output is 0. Else, the output is 1. Can you figure out the output of X: 0 1 1 0 1 1 0 0 OR Y: 1 0 1 0 0 1 1 1? Answer X V Y: 1 1 1 0 1 1 1 1 NOT Symbol for NOT is ~ Invert a bit If X is 1, ~X would be 0, and vice versa. Exclusive OR (XOR) Symbol is ⊕ If X and Y are both 0’s or 1’s, the output is 0. Else, if X and Y are both different (e.g. X is 0 and Y is 1, or X is 1 and Y is 0), the output is 1. Can you solve 0 1 1 0 1 1 0 0 ⊕ 1 0 1 0 0 1 1 1 Answer X &oplus; Y: 1 1 0 0 1 0 1 1 Modulo function Symbol can be either the word “mod” or the percentage % Modulo returns the remainder of a division operation Let’s say you divide 6 by 4, i.e. 6 / 4 The result is 1 (because 4 fits only once into 6) with a remainder value of 2 The module function outputs that remainder value 2 So: 6 mod 4 = 6 % 4 = 2 Can you figure out what 33 mod 10 is? Answer 33 mod 10 = 33 % 10 = 3 One-Way Functions]]></summary></entry><entry><title type="html">Fundamentals of Software Architecture Chapter 9 Foundations</title><link href="http://localhost:4000/architecture/2023/05/22/fundamentals-of-software-architecture-ch9.html" rel="alternate" type="text/html" title="Fundamentals of Software Architecture Chapter 9 Foundations" /><published>2023-05-22T00:00:00+02:00</published><updated>2023-05-22T00:00:00+02:00</updated><id>http://localhost:4000/architecture/2023/05/22/fundamentals-of-software-architecture-ch9</id><content type="html" xml:base="http://localhost:4000/architecture/2023/05/22/fundamentals-of-software-architecture-ch9.html"><![CDATA[<p><a href="#9-1-foundations">9.1 Foundations</a></p>

<h1 id="9-1-foundations">9 1 Foundations</h1>

<ul>
  <li>First Point</li>
</ul>]]></content><author><name></name></author><category term="architecture" /><summary type="html"><![CDATA[9.1 Foundations 9 1 Foundations First Point]]></summary></entry><entry><title type="html">Kubernetes Architecture</title><link href="http://localhost:4000/kubernetes/2023/05/22/kubernetes-architecture.html" rel="alternate" type="text/html" title="Kubernetes Architecture" /><published>2023-05-22T00:00:00+02:00</published><updated>2023-05-22T00:00:00+02:00</updated><id>http://localhost:4000/kubernetes/2023/05/22/kubernetes-architecture</id><content type="html" xml:base="http://localhost:4000/kubernetes/2023/05/22/kubernetes-architecture.html"><![CDATA[<ul>
  <li><a href="#1-architecture">1 Architecture</a>
    <ul>
      <li><a href="#1-1-kubernetes-objects">1.1 Kubernetes Objects</a></li>
      <li><a href="#1-2-kubernetes-components">1.2 Kubernetes Components</a></li>
      <li><a href="#1-3-k8s-api">1.3 K8s API</a></li>
    </ul>
  </li>
</ul>

<h2 id="1-architecture">1 Architecture</h2>

<h1 id="1-1-kubernetes-objects">1 1 Kubernetes Objects</h1>

<ul>
  <li>They can describe the state of your deployed applications</li>
  <li>Resources available to those applications</li>
  <li>Policies around how those apps behave</li>
</ul>

<h1 id="1-2-kubernetes-components">1 2 Kubernetes Components</h1>

<ul>
  <li>Kubernetes Cluster
    <ul>
      <li>Consists of multiple worker nodes / physical machines</li>
      <li>Each worker node consists of pods, which are containerized applications</li>
      <li>The K8s Control Plane usually runs on multiple computers, when in a real production environment.</li>
    </ul>
  </li>
  <li>Control Plane
    <ul>
      <li>Control plane components should ideally be deployed on machines dedicated to control plane functionality, and thus no application containers should be deployed here.</li>
      <li>Control plane components:
        <ul>
          <li>Kube-apiserver
            <ul>
              <li>Manages API access to the Kubernetes control plane.</li>
              <li>Can deploy multiple apiservers and load balance between them.</li>
            </ul>
          </li>
          <li>Etcd
            <ul>
              <li>Key-value store to store cluster data.</li>
            </ul>
          </li>
          <li>Kube-scheduler
            <ul>
              <li>When a pod gets created, the scheduler determines on which worker node it should run.
                <ul>
                  <li>This decision is based on factors such as policies, resource requirements, locality etc.</li>
                </ul>
              </li>
            </ul>
          </li>
          <li>Kube-controller-manager
            <ul>
              <li>Controls controller processes</li>
              <li>Controller processes are logically separate; but in practice, to reduce complexity, they run as one single binary</li>
              <li>Controller processes include:
                <ul>
                  <li>Node controller: handling worker nodes</li>
                  <li>Job controller: handlings jobs</li>
                  <li>ServiceAccount controller: Manages service accounts when new namespaces are created for example, etc.</li>
                </ul>
              </li>
            </ul>
          </li>
          <li>Cloud-controller-manager
            <ul>
              <li>It ensures only the necessary components in your cluster are talking to the cloud via cloud APIs, and that others are not.</li>
              <li>Further, it consists of:
                <ul>
                  <li>Node controller: Controlling nodes in the cloud, e.g. if one stops responding, checks if it’s been deleted.</li>
                  <li>Route controller: Manage/create routes in the underlying cloud infra.</li>
                  <li>Service controller: manage/create load balancers in the cloud.</li>
                </ul>
              </li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Node Components:
    <ul>
      <li>Kubelet
        <ul>
          <li>Agent running on each worker node.</li>
          <li>It creates Pods from PodSpecs</li>
          <li>It only manages K8s-created containers/Pods</li>
        </ul>
      </li>
      <li>Kube-proxy
        <ul>
          <li>Network filtering
            <ul>
              <li>Either uses underlying OS firewalling capabilities or kube-proxy does network filtering itself</li>
            </ul>
          </li>
          <li>Accept/deny network traffic from within/outside the cluster</li>
        </ul>
      </li>
      <li>Container runtime
        <ul>
          <li>E.g. Docker.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>AddOns
    <ul>
      <li>DNS
        <ul>
          <li>DNS Server for the K8s Cluster. Pods have their own FQDN.</li>
        </ul>
      </li>
      <li>Web UI
        <ul>
          <li>Troubleshoot/management console for K8s cluster and/or the applications running in pods.</li>
        </ul>
      </li>
      <li>Cluster-level logging
        <ul>
          <li>Save container logs to a central log store</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h1 id="1-3-k8s-api">1 3 K8s API</h1>
<ul>
  <li>Kubectl</li>
  <li>Kubeadm (uses kubectl in the background)</li>
  <li>Can also use REST API calls</li>
  <li>Protobuf for intra-cluster communications
    <ul>
      <li>Protocol for retrieving cluster data from etcd key-value store =&gt; serializing =&gt; … =&gt; deserializing at client =&gt; usage</li>
      <li>Apparently relatively fast</li>
    </ul>
  </li>
  <li>K8s stores serialized objects in etcd (key-value store)</li>
  <li>API Changes
    <ul>
      <li>Access a resource via v1beta1 until the API is deprecated; then you can access via new API e.g. v1. But generally you can access them via both as long as they’re both up.</li>
    </ul>
  </li>
</ul>]]></content><author><name></name></author><category term="kubernetes" /><summary type="html"><![CDATA[1 Architecture 1.1 Kubernetes Objects 1.2 Kubernetes Components 1.3 K8s API 1 Architecture 1 1 Kubernetes Objects They can describe the state of your deployed applications Resources available to those applications Policies around how those apps behave 1 2 Kubernetes Components Kubernetes Cluster Consists of multiple worker nodes / physical machines Each worker node consists of pods, which are containerized applications The K8s Control Plane usually runs on multiple computers, when in a real production environment. Control Plane Control plane components should ideally be deployed on machines dedicated to control plane functionality, and thus no application containers should be deployed here. Control plane components: Kube-apiserver Manages API access to the Kubernetes control plane. Can deploy multiple apiservers and load balance between them. Etcd Key-value store to store cluster data. Kube-scheduler When a pod gets created, the scheduler determines on which worker node it should run. This decision is based on factors such as policies, resource requirements, locality etc. Kube-controller-manager Controls controller processes Controller processes are logically separate; but in practice, to reduce complexity, they run as one single binary Controller processes include: Node controller: handling worker nodes Job controller: handlings jobs ServiceAccount controller: Manages service accounts when new namespaces are created for example, etc. Cloud-controller-manager It ensures only the necessary components in your cluster are talking to the cloud via cloud APIs, and that others are not. Further, it consists of: Node controller: Controlling nodes in the cloud, e.g. if one stops responding, checks if it’s been deleted. Route controller: Manage/create routes in the underlying cloud infra. Service controller: manage/create load balancers in the cloud. Node Components: Kubelet Agent running on each worker node. It creates Pods from PodSpecs It only manages K8s-created containers/Pods Kube-proxy Network filtering Either uses underlying OS firewalling capabilities or kube-proxy does network filtering itself Accept/deny network traffic from within/outside the cluster Container runtime E.g. Docker. AddOns DNS DNS Server for the K8s Cluster. Pods have their own FQDN. Web UI Troubleshoot/management console for K8s cluster and/or the applications running in pods. Cluster-level logging Save container logs to a central log store 1 3 K8s API Kubectl Kubeadm (uses kubectl in the background) Can also use REST API calls Protobuf for intra-cluster communications Protocol for retrieving cluster data from etcd key-value store =&gt; serializing =&gt; … =&gt; deserializing at client =&gt; usage Apparently relatively fast K8s stores serialized objects in etcd (key-value store) API Changes Access a resource via v1beta1 until the API is deprecated; then you can access via new API e.g. v1. But generally you can access them via both as long as they’re both up.]]></summary></entry><entry><title type="html">The Linux Programming Interface Chapter 12 Summary</title><link href="http://localhost:4000/tlpi/2023/05/22/tlpi-ch12.html" rel="alternate" type="text/html" title="The Linux Programming Interface Chapter 12 Summary" /><published>2023-05-22T00:00:00+02:00</published><updated>2023-05-22T00:00:00+02:00</updated><id>http://localhost:4000/tlpi/2023/05/22/tlpi-ch12</id><content type="html" xml:base="http://localhost:4000/tlpi/2023/05/22/tlpi-ch12.html"><![CDATA[<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>• /proc filesystem
	○ How many files are currently locked?
		§ Which processes are holding those locks?
	○ How many files is a process holding?
	○ Basically, getting information about processes.
	○ What sockets are being used?
• Traditionally, older UNIX implementations allowed privileged programs to access kernel data structures/memory directly to find information related to processes. This caused some problems.
	○ Now, the kernel provides a virtual file system under /proc.
		§ A virtual file system does not reside on disk; it is created on-the-fly when a program needs access to /proc to get/(set) process information.
	○ Programs can in a more convenient way access processes information via /proc and make changes to some aspects using system calls and regular file I/O.
• /proc/PID
	○ Contains process information
	○ /proc/PID/status
		§ This file contains the status of the process
		§ Because /proc/PID/status tends to change over time, don't parse the file by line number
			□ PARSE BY THE STRING, e.g. PPID: &lt;number&gt; which may change from being on line 7 to line 17 as new things are added to the file.
	○ Other files: cwd (current working dir), exe (symlink to file being executed), environ (env list), cmdline (cmdline arguments), mounts (mount points for the process), etc…
• /proc/PID/fd directory
	○ E.g. /proc/PID/fd/1 is a symlink to stdout (standard output) for that process
• A process can access its own /proc/PID dir through /proc/self
• Threads: /proc/PID/task/&lt;thread-id&gt;
	○ Because threads share memory, similar information is stored across threads under the corresponding thread-id directory.
	○ Information that might differ in for e.g. the status file are things like the current state of the thread, signals-related information and some other things.
• Various sub-directories for various settings
	○ /proc/net - networking/sockets settings
	○ /proc/sys/net - networking/sockets again
	○ Proc/kernel - kernel settings
	○ Etc
• Who/when can we modify /proc files?
	○ /proc/PID files can be modified by root or, for some of the files (e.g. environ), only the file owner (i.e. the user who created the process)
	○ Some files are read-only, meaning they cannot be modified, e.g. those that simply display kernel info
	○ Most files under /proc are owned by root, meaning only root can modify them.
• Uname(&amp;uts)
	○ Uts is a struct with a bunch of fields such as version, machine, system name, release etc…
	○ Basically uname returns a bunch of information about the host system.
</code></pre></div></div>

<p><img src="/docs/assets/images/tlpi-ch12/tlpi-ch12-1.jpg" alt="Image" /></p>]]></content><author><name></name></author><category term="tlpi" /><summary type="html"><![CDATA[• /proc filesystem ○ How many files are currently locked? § Which processes are holding those locks? ○ How many files is a process holding? ○ Basically, getting information about processes. ○ What sockets are being used? • Traditionally, older UNIX implementations allowed privileged programs to access kernel data structures/memory directly to find information related to processes. This caused some problems. ○ Now, the kernel provides a virtual file system under /proc. § A virtual file system does not reside on disk; it is created on-the-fly when a program needs access to /proc to get/(set) process information. ○ Programs can in a more convenient way access processes information via /proc and make changes to some aspects using system calls and regular file I/O. • /proc/PID ○ Contains process information ○ /proc/PID/status § This file contains the status of the process § Because /proc/PID/status tends to change over time, don't parse the file by line number □ PARSE BY THE STRING, e.g. PPID: &lt;number&gt; which may change from being on line 7 to line 17 as new things are added to the file. ○ Other files: cwd (current working dir), exe (symlink to file being executed), environ (env list), cmdline (cmdline arguments), mounts (mount points for the process), etc… • /proc/PID/fd directory ○ E.g. /proc/PID/fd/1 is a symlink to stdout (standard output) for that process • A process can access its own /proc/PID dir through /proc/self • Threads: /proc/PID/task/&lt;thread-id&gt; ○ Because threads share memory, similar information is stored across threads under the corresponding thread-id directory. ○ Information that might differ in for e.g. the status file are things like the current state of the thread, signals-related information and some other things. • Various sub-directories for various settings ○ /proc/net - networking/sockets settings ○ /proc/sys/net - networking/sockets again ○ Proc/kernel - kernel settings ○ Etc • Who/when can we modify /proc files? ○ /proc/PID files can be modified by root or, for some of the files (e.g. environ), only the file owner (i.e. the user who created the process) ○ Some files are read-only, meaning they cannot be modified, e.g. those that simply display kernel info ○ Most files under /proc are owned by root, meaning only root can modify them. • Uname(&amp;uts) ○ Uts is a struct with a bunch of fields such as version, machine, system name, release etc… ○ Basically uname returns a bunch of information about the host system.]]></summary></entry><entry><title type="html">The Linux Programming Interface Chapter 6 Processes Summary</title><link href="http://localhost:4000/tlpi/2023/05/22/tlpi-ch6.html" rel="alternate" type="text/html" title="The Linux Programming Interface Chapter 6 Processes Summary" /><published>2023-05-22T00:00:00+02:00</published><updated>2023-05-22T00:00:00+02:00</updated><id>http://localhost:4000/tlpi/2023/05/22/tlpi-ch6</id><content type="html" xml:base="http://localhost:4000/tlpi/2023/05/22/tlpi-ch6.html"><![CDATA[<p><a href="#6-1">6.1</a></p>

<p><a href="#6-2">6.2</a></p>

<p><a href="#6-3-memory-layout-of-a-process">6.3 Memory Layout of a Process</a></p>

<p><a href="#6-4-virtual-memory-management">6.4 Virtual Memory Management</a></p>

<p><a href="#6-6-command-line-arguments">6.6 Command Line Arguments</a></p>

<p><a href="#6-7-environment-list">6.7 Environment List</a></p>

<p><a href="#6-8-performing-a-non-local-goto">6.8 Performing a Non Local GoTo</a></p>

<h1 id="6-1">6 1</h1>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>• A program on disk consists of the following:
	1. Binary identification.
		i. What file-format it is. On Linux, ELF (Executable &amp; Linking format).
	2. Machine instructions.
	3. Location of entry-point (main function).
	4. Data/constants/strings.
	5. Names of variables/functions.
	6. Shared libraries.
	7. Other information on how to construct a process.
• Kernel data structures involved in maintaining a process:
	○ Virtual memory table/information.
	○ File descriptor table.
	○ Signal handling information.
	○ Resource usage/limits.
</code></pre></div></div>

<h1 id="6-2">6 2</h1>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>• Process ID (PID).
• Pid_t Getpid(void).
	○ Pid_t is an integer type.
• Maximum process ID number is 32,767. This is defined as a PID_MAX macro in Linux kernel.
• The PID number can be increased via /proc/sys/kernel/pid_max file.
• When the maximum PID number is reached, it begins from a low number again (PID 300, not PID 1, because PID 1 - 300 are often used by system daemons and processes).
• Pid_t getppid(void) - gets parent PID.
	○ See family tree of processes with pstree.
</code></pre></div></div>

<h1 id="6-3-memory-layout-of-a-process">6 3 Memory Layout of a Process</h1>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>• The layout:
	1. Machine instructions. Each process-instance of the program points to these machine instructions (and initialized/uninitialized data segments, described below).
	2. Initialized data segments. Explicitly declared variables.
		i. E.g. int I = 10;
	3. Uninitialized data segments, e.g. int I;. Not explicitly declared variables.
	4. Stack.
		i. Each new function call gets a stack frame in the stack.
		ii. Contains the function's local variables, parameters and return value.
	5. Heap.
		i. For dynamically allocating memory.
• (Un)initialized data in main() function get stored in the (un)initialized data segments (and not main()'s stack frame), whereas such data in another function get stored in the stack frame of that function.
• Application Binary Interface (ABI) - set of rules for communication. A binary executable informs kernel/some library on how they should exchange certain important information. The ABI tells the kernel which registers and stack locations it will use to exchange this information.
• Extern char etext, edata, end.
	○ Extern char etext is the next byte after the end of the program text/code/instructions.
	○ Edata is the unintiialized data segment.
	○ End is the init data segment.
</code></pre></div></div>

<h1 id="6-4-virtual-memory-management">6 4 Virtual Memory Management</h1>

<p><img src="/docs/assets/images/tlpi-6.4-1.jpg" alt="Image" /></p>

<p><img src="/docs/assets/images/tlpi-6.4-2.png" alt="Image" /></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>• Locality of reference
	○ Temporal locality
		§ A program will use the same information again if it used it recently
	○ Spatial locality
		§ A program will use information close to information it recently used
• RAM is divided into page frames
• Virtual memory is divided into pages as well
• Page size on Linux x86-32 = 4096 bytes
• Swap
	○ Can be used to store additional, unused pages.
		§ If a process requests a page that happens to be in swap, page fault occurs: kernel must pause the process's execution and fetch the page(s).
• Each process has a virtual page table.
	○ Each element in the virtual page table points to a page in virtual address memory.
		§ Each of these elements in turn point to either physical RAM memory where the page is stored, or indicate that the page is on disk.
	○ If a process tries to access an element in the virtual page table that does not exist, a SIGSEGV signal is sent.
		§ Unusued memory do not have to be added as entries in the virtual page table.
• 4 situations when virtual address space of a process can change as kernel allocates/deallocates memory:
	○ Stack grows downward
	○ Heap grows
	○ System-V related things
	○ Mmap() or munmap() is used
• There are 3 main benefits to mapping virtual addresses' of processes to physical RAM memory:
	○ Isolation
		§ A process only has access to the physical RAM pages that are mapped to that process's page table.
	○ Memory sharing
		§ Processes can share code, data, without duplicating it.
	○ Memory protection
		§ You can have different access privileges set for different processes for the same data.
			□ e.g. read for pid7, read-write for pid10.
• Stack starts at high address, and grows downward.
	○ Whenever a function call or global/main variable declaration is made, a stack frame is added.
	○ There's a register that keeps track of the current "top" of the stack, i.e. the end of the stack in the direction it grows in.
• Kernel memory/stack at beginning of each process
	○ If that user process makes a syscall, kernel can use this separate stack to add function calls.
• Functions use a program counter CPU register to keep track of which machine instructions to execute next.
	○ If another function is called, the new stack frame of the called function includes this machine instruction so that it can be saved, so that once the called function returns, the original function knows what to do.
</code></pre></div></div>

<p><img src="/docs/assets/images/tlpi-6.4-3.jpg" alt="Image" /></p>

<p><img src="/docs/assets/images/tlpi-6.4-4.png" alt="Image" /></p>

<h1 id="6-6-command-line-arguments">6 6 Command Line Arguments</h1>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>• Argc/argv
• Argv[0] is the name of the program
	○ The program can check the name used when calling it by looking at argv[0]
	○ The program can then have different behavior if for example the user called gzip as opposed to gunzip.
• The array of elements is terminated by a NULL-byte char, i.e. argv[argc] is NULL.
	○ Each string in argv[] is also null-terminated.
• Non-portable method of accessing commandline arguments on Linux:
	○ /proc/PID/cmdline
	○ Or /proc/self/cmdline if the process is getting its own cmdline args.
• ARG_MAX value, i.e. total number of bytes that can be supplied via args.
	○ Total space for argv and environ (env variables sorta) can be specified with RLIMIT_STACK resource limit.
</code></pre></div></div>

<h1 id="6-7-environment-list">6 7 Environment List</h1>

<p><img src="/docs/assets/images/tlpi-6.4-environ.png" alt="Image" /></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>• Children inherit parent data
• Environment variables: name=value pairs.
• Export SHELL=/bin/sh
	○ This is an example of an env var
	○ Printenv to see a list of all env vars
	○ Env list of any process can be found at /proc/PID/environ
• Accessing the environment from a C program
	○ **environ points to an array, where each element points to the environment variables
	○ Stepping through this array is done with pointers, even though it's an array.
		§ Reason being that there is no argc value that specifies the size of the environ array.
	○ Getenv(name) returns point to the value of an environment variable name
		§ THIS IS PORTABLE!!
	○ You can also make changes to environment variables with putenv() and setenv().
		§ Use case: when you use fork() to create child processes, you want the child processes to also have this modified environment.
	○ Executing SUID (set-used-ID) programs securely may require using clearenv() to clear all env vars first.
	○ When you call setenv(), a memory buffer is allocated to store the name=value pair.
		§ If a program repeatedly calls setenv() and clearenv(), this memory buffer does NOT get free'd.
			□ This could lead to memory leaks.
			□ In practice, it does not, because programs tend to use clearenv() only on startup.
</code></pre></div></div>

<h1 id="6-8-performing-a-non-local-goto">6 8 Performing a Non Local GoTo</h1>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>• Nonlocal goto means going from e.g. a function to some other memory area outside of the function.
• Caveat: you cannot goto another function from a current function using goto, but you CAN using setjmp() and longjmp().
• Example use case:
	○ Imagine multiple functions being called in a stack.
	○ Each called function supplies its caller with a status value.
	○ If an error status occurs at any stage, to go back to a normally executing function, we might have to pop several function calls from the stack.
		§ Instead of going one by one, we can use the setjmp() and longjmp() commands to directly jump back to an OK function.
• C does not allow for nested functions e.g. where you define X() then within X() you define Y(). So compiler has no way of knowing if Y is on the stack if a goto is written in X(). Pascal for example allows for this nesting and can thus in certain scenarios determine that a goto is possible.
• Jump calls:
	○ Setjmp(jmp_buf env);
		§ Returns 0 on initial return, val when a longjmp() returns to setjmp()
	○ Longjmp(jmp_buf env, int val);
		§ Val specifies  a value to supply the setjmp() with. That way, you can use val to distinguish which part of the program called setjmp(). If val is set to 0, it is automatically changed to 1 to avoid being misinterpreted as being the default 0.
	○ Env stores the following:
		1. Stack pointer register (that points to the top of the stack) (so it can "erase" unneeded function calls by simply moving the pointer to the same place it was when setjmp() was declared when longjmp() is called, accomplishing our intended purpose)
		2. Program counter register (so it knows where setjmp() was executing from)
		• Env usually declared as a global var (or, less commonly, passed as function param)
	○ There are restrictions specified by SUSv3 and C99 on when setjmp() can be used. Examples include:
		• If/while/switch
		• Etc
		• S = setjmp(env); is not standards conformant
			□ Somehow cannot guarantee setjmp() in this way has all the necessary info to save register values and the full stack.
• Abusing longjmp()
	1. Declare global buffer env.
	2. Inside x(), setjmp().
	3. x() returns.
	4. y() calls longjmp() to the setjmp() inside x().
		• PROBLEM: x() is NOT on the stack! Chaos ensues. Program crash or infinite call-return loop, where the program thinks it's returning from a legitimate call.
• Setjmp/longjmp are ran at run-time, not during lexical analysis by the compiler during compilation time.
	○ In some cases, due to compiler optimizations, because setjmp/longjmp may not store all relevant register values, could lead to wrong values being returned after a longjmp.
	○ Any local variables that the compiler does optimizations for (which may include code REORGANIZATION, which explains the /proc/setjmp_vars.c result to some degree), and most commonly Pointer variables and simple types such as char, int, float, and long are vulnerable.
		• Declare each local variable that may be impacted by setjmp/longjmp as "VOLATILE" to tell the compiler NOT to do optimizations for it.
	○ See /proc/setjmp_vars.c
    * You should generally avoid using set/longjmp due to po
</code></pre></div></div>]]></content><author><name></name></author><category term="tlpi" /><summary type="html"><![CDATA[6.1 6.2 6.3 Memory Layout of a Process 6.4 Virtual Memory Management 6.6 Command Line Arguments 6.7 Environment List 6.8 Performing a Non Local GoTo 6 1 • A program on disk consists of the following: 1. Binary identification. i. What file-format it is. On Linux, ELF (Executable &amp; Linking format). 2. Machine instructions. 3. Location of entry-point (main function). 4. Data/constants/strings. 5. Names of variables/functions. 6. Shared libraries. 7. Other information on how to construct a process. • Kernel data structures involved in maintaining a process: ○ Virtual memory table/information. ○ File descriptor table. ○ Signal handling information. ○ Resource usage/limits. 6 2 • Process ID (PID). • Pid_t Getpid(void). ○ Pid_t is an integer type. • Maximum process ID number is 32,767. This is defined as a PID_MAX macro in Linux kernel. • The PID number can be increased via /proc/sys/kernel/pid_max file. • When the maximum PID number is reached, it begins from a low number again (PID 300, not PID 1, because PID 1 - 300 are often used by system daemons and processes). • Pid_t getppid(void) - gets parent PID. ○ See family tree of processes with pstree. 6 3 Memory Layout of a Process • The layout: 1. Machine instructions. Each process-instance of the program points to these machine instructions (and initialized/uninitialized data segments, described below). 2. Initialized data segments. Explicitly declared variables. i. E.g. int I = 10; 3. Uninitialized data segments, e.g. int I;. Not explicitly declared variables. 4. Stack. i. Each new function call gets a stack frame in the stack. ii. Contains the function's local variables, parameters and return value. 5. Heap. i. For dynamically allocating memory. • (Un)initialized data in main() function get stored in the (un)initialized data segments (and not main()'s stack frame), whereas such data in another function get stored in the stack frame of that function. • Application Binary Interface (ABI) - set of rules for communication. A binary executable informs kernel/some library on how they should exchange certain important information. The ABI tells the kernel which registers and stack locations it will use to exchange this information. • Extern char etext, edata, end. ○ Extern char etext is the next byte after the end of the program text/code/instructions. ○ Edata is the unintiialized data segment. ○ End is the init data segment. 6 4 Virtual Memory Management • Locality of reference ○ Temporal locality § A program will use the same information again if it used it recently ○ Spatial locality § A program will use information close to information it recently used • RAM is divided into page frames • Virtual memory is divided into pages as well • Page size on Linux x86-32 = 4096 bytes • Swap ○ Can be used to store additional, unused pages. § If a process requests a page that happens to be in swap, page fault occurs: kernel must pause the process's execution and fetch the page(s). • Each process has a virtual page table. ○ Each element in the virtual page table points to a page in virtual address memory. § Each of these elements in turn point to either physical RAM memory where the page is stored, or indicate that the page is on disk. ○ If a process tries to access an element in the virtual page table that does not exist, a SIGSEGV signal is sent. § Unusued memory do not have to be added as entries in the virtual page table. • 4 situations when virtual address space of a process can change as kernel allocates/deallocates memory: ○ Stack grows downward ○ Heap grows ○ System-V related things ○ Mmap() or munmap() is used • There are 3 main benefits to mapping virtual addresses' of processes to physical RAM memory: ○ Isolation § A process only has access to the physical RAM pages that are mapped to that process's page table. ○ Memory sharing § Processes can share code, data, without duplicating it. ○ Memory protection § You can have different access privileges set for different processes for the same data. □ e.g. read for pid7, read-write for pid10. • Stack starts at high address, and grows downward. ○ Whenever a function call or global/main variable declaration is made, a stack frame is added. ○ There's a register that keeps track of the current "top" of the stack, i.e. the end of the stack in the direction it grows in. • Kernel memory/stack at beginning of each process ○ If that user process makes a syscall, kernel can use this separate stack to add function calls. • Functions use a program counter CPU register to keep track of which machine instructions to execute next. ○ If another function is called, the new stack frame of the called function includes this machine instruction so that it can be saved, so that once the called function returns, the original function knows what to do. 6 6 Command Line Arguments • Argc/argv • Argv[0] is the name of the program ○ The program can check the name used when calling it by looking at argv[0] ○ The program can then have different behavior if for example the user called gzip as opposed to gunzip. • The array of elements is terminated by a NULL-byte char, i.e. argv[argc] is NULL. ○ Each string in argv[] is also null-terminated. • Non-portable method of accessing commandline arguments on Linux: ○ /proc/PID/cmdline ○ Or /proc/self/cmdline if the process is getting its own cmdline args. • ARG_MAX value, i.e. total number of bytes that can be supplied via args. ○ Total space for argv and environ (env variables sorta) can be specified with RLIMIT_STACK resource limit. 6 7 Environment List • Children inherit parent data • Environment variables: name=value pairs. • Export SHELL=/bin/sh ○ This is an example of an env var ○ Printenv to see a list of all env vars ○ Env list of any process can be found at /proc/PID/environ • Accessing the environment from a C program ○ **environ points to an array, where each element points to the environment variables ○ Stepping through this array is done with pointers, even though it's an array. § Reason being that there is no argc value that specifies the size of the environ array. ○ Getenv(name) returns point to the value of an environment variable name § THIS IS PORTABLE!! ○ You can also make changes to environment variables with putenv() and setenv(). § Use case: when you use fork() to create child processes, you want the child processes to also have this modified environment. ○ Executing SUID (set-used-ID) programs securely may require using clearenv() to clear all env vars first. ○ When you call setenv(), a memory buffer is allocated to store the name=value pair. § If a program repeatedly calls setenv() and clearenv(), this memory buffer does NOT get free'd. □ This could lead to memory leaks. □ In practice, it does not, because programs tend to use clearenv() only on startup. 6 8 Performing a Non Local GoTo • Nonlocal goto means going from e.g. a function to some other memory area outside of the function. • Caveat: you cannot goto another function from a current function using goto, but you CAN using setjmp() and longjmp(). • Example use case: ○ Imagine multiple functions being called in a stack. ○ Each called function supplies its caller with a status value. ○ If an error status occurs at any stage, to go back to a normally executing function, we might have to pop several function calls from the stack. § Instead of going one by one, we can use the setjmp() and longjmp() commands to directly jump back to an OK function. • C does not allow for nested functions e.g. where you define X() then within X() you define Y(). So compiler has no way of knowing if Y is on the stack if a goto is written in X(). Pascal for example allows for this nesting and can thus in certain scenarios determine that a goto is possible. • Jump calls: ○ Setjmp(jmp_buf env); § Returns 0 on initial return, val when a longjmp() returns to setjmp() ○ Longjmp(jmp_buf env, int val); § Val specifies a value to supply the setjmp() with. That way, you can use val to distinguish which part of the program called setjmp(). If val is set to 0, it is automatically changed to 1 to avoid being misinterpreted as being the default 0. ○ Env stores the following: 1. Stack pointer register (that points to the top of the stack) (so it can "erase" unneeded function calls by simply moving the pointer to the same place it was when setjmp() was declared when longjmp() is called, accomplishing our intended purpose) 2. Program counter register (so it knows where setjmp() was executing from) • Env usually declared as a global var (or, less commonly, passed as function param) ○ There are restrictions specified by SUSv3 and C99 on when setjmp() can be used. Examples include: • If/while/switch • Etc • S = setjmp(env); is not standards conformant □ Somehow cannot guarantee setjmp() in this way has all the necessary info to save register values and the full stack. • Abusing longjmp() 1. Declare global buffer env. 2. Inside x(), setjmp(). 3. x() returns. 4. y() calls longjmp() to the setjmp() inside x(). • PROBLEM: x() is NOT on the stack! Chaos ensues. Program crash or infinite call-return loop, where the program thinks it's returning from a legitimate call. • Setjmp/longjmp are ran at run-time, not during lexical analysis by the compiler during compilation time. ○ In some cases, due to compiler optimizations, because setjmp/longjmp may not store all relevant register values, could lead to wrong values being returned after a longjmp. ○ Any local variables that the compiler does optimizations for (which may include code REORGANIZATION, which explains the /proc/setjmp_vars.c result to some degree), and most commonly Pointer variables and simple types such as char, int, float, and long are vulnerable. • Declare each local variable that may be impacted by setjmp/longjmp as "VOLATILE" to tell the compiler NOT to do optimizations for it. ○ See /proc/setjmp_vars.c * You should generally avoid using set/longjmp due to po]]></summary></entry></feed>